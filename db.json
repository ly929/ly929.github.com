{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/assets/head2.gif","path":"assets/head2.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/assets/head.gif","path":"assets/head.gif","modified":0,"renderable":1},{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"98795ec72d1e623093d13b25483186187ee9fff8","modified":1551962011531},{"_id":"source/README.md","hash":"4da118ab26fd009d93305d3466152218d2b5e680","modified":1555920104189},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1548311554650},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1548311554650},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1548311554650},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1548311554650},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1548311554666},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1548311554666},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1548311554666},{"_id":"themes/yilia/_config.yml","hash":"5cbc7868c0dc0c1246f4d5453b4a74d956be71c8","modified":1556087034415},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1548311554681},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1548311554728},{"_id":"source/_posts/HashMap常见问答.md","hash":"345a72bd5aed2c3953b99d32f458c09b7df07adb","modified":1556000874955},{"_id":"source/_posts/Java代码的执行顺序.md","hash":"babd2fae8d4ee3b4dc8db30a6a4aa26e9aaaae1a","modified":1556007529794},{"_id":"source/_posts/Java多线程的3个核心.md","hash":"0856ebe11714dd0d721b63fbf32520c988e2bccb","modified":1555917646144},{"_id":"source/_posts/Shadowsocks-Python版一键安装脚本.md","hash":"5459d41e4e8466fc7683c35b10e3278334f0d215","modified":1551962699509},{"_id":"source/_posts/Sql语句中的DDL、DML、DCL的介绍.md","hash":"27af8caca1582eacf98ec439bdc240f09fdcac32","modified":1555917641165},{"_id":"source/_posts/hello-world.md","hash":"1b00989a36a92280a723aa1836936dbec9a6cb44","modified":1552912679146},{"_id":"source/_posts/jvm-GC策略.md","hash":"84edefea4ee209e4247357a190934c6cab972491","modified":1555919218306},{"_id":"source/_posts/jvm内存组成.md","hash":"3ee4fcd2581f2af8b62c89a613154d4f5cceada6","modified":1555918706857},{"_id":"source/_posts/tomcat 出现的PermGen Space问题.md","hash":"d1ad6ea2bc2a156e8339f2f1bce0a03ea3da3219","modified":1555917649915},{"_id":"source/_posts/what-happen-when.md","hash":"ab19b6255937d98f1792579c3ac19aaea1294a99","modified":1556089144065},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1548311554666},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1548311554666},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1548311554666},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1548311554666},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1548311554666},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1548311554666},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1548311554666},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1548311554681},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1548311554681},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1548311554681},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1548311554681},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1548311554681},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1548311554681},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1548311554681},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1548311554681},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1548311554728},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1548311554728},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1548311554728},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1548311554681},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1548311554728},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1548311554728},{"_id":"source/_posts/HashMap常见问答/14101204468.jpeg","hash":"9154e2cdb9ab446f329ad640b08111938cb51ac6","modified":1548905585411},{"_id":"source/_posts/Java代码的执行顺序/1.png","hash":"610ad4ac5998a4a93186adc40cc694a8b4c0f2d3","modified":1556005085637},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"5b9daf25447826752cdc121fc3de00356fb4bb0c","modified":1556084210287},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"3192395ad7b330fb727fde03b5440dc73dacf348","modified":1548671238571},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1556089109233},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1548311554666},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1548311554681},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1548311554681},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1548311554681},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1548311554697},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1548311554697},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1548311554697},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1548311554697},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1548311554697},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1548311554697},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1548311554697},{"_id":"themes/yilia/source-src/css/declare.scss","hash":"685bcbdc9f36bb600e5ca09f5d6009f653d18a87","modified":1548320490467},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1548311554697},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1548311554697},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1548311554697},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1548311554697},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1548311554697},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1548318627025},{"_id":"themes/yilia/source-src/css/main.scss","hash":"bb7ecb32353c3c699ac3a723e24771085338b0d0","modified":1548320515948},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1548311554713},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1548311554713},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1548311554713},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1548311554713},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1548311554713},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1548311554713},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1548311554713},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1548311554713},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1548311554713},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1548311554713},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1548311554713},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1548311554713},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1548311554713},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1548311554713},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1548311554713},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1548311554713},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1548311554713},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1548311554713},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1548311554713},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1548311554713},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1548311554713},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1548311554713},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1548311554728},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1548311554728},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1548311554728},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1548311554728},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1548311554728},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1548311554728},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1548311554728},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1548311554728},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1548311554728},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1548311554728},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/livere.ejs","hash":"bf783ab8ba9911fb589f4e679abf7d64a43eb817","modified":1556077088897},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1548311554681},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1548311554681},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1548311554697},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1548311554697},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1548311554697},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1548311554697},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1548311554697},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1548311554697},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1548311554697},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1548311554697},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1548311554697},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1548311554697},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1548311554713},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1548311554713},{"_id":"source/_posts/jvm内存组成/memory-area1.png","hash":"64dbb23fdcff3378d44b31855fdf03467ecefd7f","modified":1555918263172},{"_id":"themes/yilia/source/assets/head2.gif","hash":"bea857faffd77c44a9f5b1cc2a1daa07090b700b","modified":1459843288106},{"_id":"themes/yilia/source/assets/head.gif","hash":"90e7b876bdc62e01f49cc0243043be00fcda4d18","modified":1545703283206},{"_id":"public/content.json","hash":"1cb374c9267edc2b11c472dd6d713fd5043acbd8","modified":1556081541632},{"_id":"public/2019/04/23/Java代码的执行顺序/index.html","hash":"b0a5bcb9272a47f3ff8216fa2a2b3f3709b0d93e","modified":1556086877057},{"_id":"public/2019/04/22/HashMap常见问答/index.html","hash":"12717aaff5624b842f0e103d3a222d817d0503cf","modified":1556086877058},{"_id":"public/2019/04/22/jvm-GC策略/index.html","hash":"f2f93eb2714993d15b31d042f816c0de74471273","modified":1556086877058},{"_id":"public/2019/04/22/jvm内存组成/index.html","hash":"0af8d727d7a043c6a478517ff49abaf07a6081cd","modified":1556086877059},{"_id":"public/2019/03/18/Sql语句中的DDL、DML、DCL的介绍/index.html","hash":"db6676b7d5f9a8bed04d7786c4719b5343753fb3","modified":1556086877059},{"_id":"public/2019/03/18/what-happen-when/index.html","hash":"e295bd5e0691b5ad0de4fde7c5962187f29a6127","modified":1556086877059},{"_id":"public/2019/03/05/tomcat 出现的PermGen Space问题/index.html","hash":"ccc0d6989912aa0090fb8bd8ea5780062d05d0ea","modified":1556086877060},{"_id":"public/2019/03/05/Shadowsocks-Python版一键安装脚本/index.html","hash":"e74316dfb7fe47e12bfafe64052238be2981f98b","modified":1556086877060},{"_id":"public/2019/03/05/Java多线程的3个核心/index.html","hash":"08bca7e3c452626e944a7d78c6699c0d8a9fd50e","modified":1556086877060},{"_id":"public/2019/01/24/hello-world/index.html","hash":"d49240b2808faaa0bdb7add938a4b9fc3325aa93","modified":1556086877060},{"_id":"public/archives/index.html","hash":"73b67b5e66d21002c1d793fcfc26d93fc51811f5","modified":1556085653371},{"_id":"public/archives/2019/index.html","hash":"6dd61f5ac4e125108ef1d489e99409b97a4e3f7f","modified":1556085653372},{"_id":"public/archives/2019/01/index.html","hash":"5811a37ae53c6be084e5a6f31bb0c0e72f700b24","modified":1556085653372},{"_id":"public/archives/2019/03/index.html","hash":"fd0a19a1d10ff1c1c6b5844bf20ccab9e2cf3549","modified":1556085653372},{"_id":"public/archives/2019/04/index.html","hash":"c0db7728a203b8dacc61e75aef809b06c4276a7a","modified":1556085653372},{"_id":"public/categories/Java/index.html","hash":"17984393e89ae365cd4a09fbf5501c727746646f","modified":1556085653373},{"_id":"public/categories/test/index.html","hash":"e2215bc99c45423f4f59667b1d139fe3e4147be8","modified":1556085653373},{"_id":"public/categories/jvm/index.html","hash":"24cb93ff5522887d173e81ad5f01cf6f9940249a","modified":1556085653373},{"_id":"public/index.html","hash":"561e68c4ca39daef69ab44cdb679ea06803290fc","modified":1556085653373},{"_id":"public/tags/HashMap/index.html","hash":"ed1b94fa5048127103ad32b3da85626703e6a275","modified":1556085653374},{"_id":"public/tags/Java/index.html","hash":"7d0e8b898773b48bba6cbfb16f2f712513387e7a","modified":1556085653374},{"_id":"public/tags/Java-多线程/index.html","hash":"0a3caecf544f036598e8a61ceec7e26c0cba4f1d","modified":1556085653374},{"_id":"public/tags/Shadowsocks/index.html","hash":"9c869009d84fef1d8baa7a7c7d51660ef4e08326","modified":1556085653374},{"_id":"public/tags/sql/index.html","hash":"34579d1437152a57c560bb7acb25073e2e129e34","modified":1556085653374},{"_id":"public/tags/test/index.html","hash":"2ab68a2c400cbe727629ebc237eb84be48df372c","modified":1556085653375},{"_id":"public/tags/jvm内存/index.html","hash":"7b24c3576bf90dd5759a6ad2dce5f726e850b82d","modified":1556085653375},{"_id":"public/tags/Tomcat/index.html","hash":"886236db2cbcc207397714203e479828f3f6ac34","modified":1556085653375},{"_id":"public/tags/其他/index.html","hash":"19ab32efe186a153d0d68233086663110ffe681b","modified":1556085653375},{"_id":"public/CNAME","hash":"98795ec72d1e623093d13b25483186187ee9fff8","modified":1556081543139},{"_id":"public/README.md","hash":"4da118ab26fd009d93305d3466152218d2b5e680","modified":1556081543140},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1556081543140},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1556081543140},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1556081543140},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1556081543140},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1556081543140},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1556081543140},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1556081543140},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1556081543141},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1556081543141},{"_id":"public/2019/04/22/HashMap常见问答/14101204468.jpeg","hash":"9154e2cdb9ab446f329ad640b08111938cb51ac6","modified":1556081543141},{"_id":"public/2019/04/23/Java代码的执行顺序/1.png","hash":"610ad4ac5998a4a93186adc40cc694a8b4c0f2d3","modified":1556081543141},{"_id":"public/live2dw/assets/miku.model.json","hash":"32e49dfc6cb4d9c537453bb083aab39ed708c476","modified":1556081543141},{"_id":"public/live2dw/assets/miku.physics.json","hash":"d5ca7f215044ba5bf1cdb8045a5c99b64ec258ce","modified":1556081543141},{"_id":"public/live2dw/assets/mtn/miku_idle_01.mtn","hash":"5633f73601cf8b0a318e7a7265f71cc782683251","modified":1556081543141},{"_id":"public/live2dw/assets/mtn/miku_m_01.mtn","hash":"bd0ea5f2f0528b21c4e5632838b69e478b652e88","modified":1556081543141},{"_id":"public/live2dw/assets/mtn/miku_m_02.mtn","hash":"2eda9602d626d89285e0c0c5f564383964516cc8","modified":1556081543141},{"_id":"public/live2dw/assets/mtn/miku_m_03.mtn","hash":"94ef9d31a78f7f90d3fb213c4353afbdb3462cff","modified":1556081543141},{"_id":"public/live2dw/assets/mtn/miku_m_04.mtn","hash":"5c440e8f4cd45e73a7c8044ea0e2ea11234f9fd9","modified":1556081543141},{"_id":"public/live2dw/assets/mtn/miku_m_05.mtn","hash":"73b9b162c1dbf9a6747364ae47b12cba9da0bbec","modified":1556081543142},{"_id":"public/live2dw/assets/mtn/miku_m_06.mtn","hash":"0bfd6ad29e5e171a1ce03a7acb8ffcca9f463902","modified":1556081543142},{"_id":"public/live2dw/assets/mtn/miku_shake_01.mtn","hash":"190875ab6cdeee7ae87c4c296429b848c942dd8a","modified":1556081543142},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"6e013af9c502b2e63ac5e42944e3244f8f515eb7","modified":1556081543142},{"_id":"public/2019/04/22/jvm内存组成/memory-area1.png","hash":"64dbb23fdcff3378d44b31855fdf03467ecefd7f","modified":1556081543165},{"_id":"public/live2dw/assets/moc/miku.moc","hash":"a57e92e12f1fcb21d4d3a9ac34f01badbeff3671","modified":1556081543165},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"7d3a9c937317b9c15f2c3a872f0e26607a729458","modified":1556081543165},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"5e7669733ecd0b1bc3881d2cf7fcc01e2990a07d","modified":1556081543178},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1556081543243},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1556081543252},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"09521263ecc625a246b3406c385300e99e966a2e","modified":1556081543252},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1556081543258},{"_id":"public/live2dw/assets/moc/miku.2048/texture_00.png","hash":"26fe101720ab8e55fb62c87b563d0dbb903c5eaf","modified":1556081543265},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1556081543282},{"_id":"public/assets/head2.gif","hash":"bea857faffd77c44a9f5b1cc2a1daa07090b700b","modified":1556081543285},{"_id":"public/assets/head.gif","hash":"90e7b876bdc62e01f49cc0243043be00fcda4d18","modified":1556081543316},{"_id":"source/favicon.png","hash":"df17cbc9c8ebec4a41eee7386e7bc7492a51b30d","modified":1495705981057},{"_id":"public/favicon.png","hash":"df17cbc9c8ebec4a41eee7386e7bc7492a51b30d","modified":1556082842222}],"Category":[{"name":"Java","_id":"cjuuqqv5n0005ucxvpnajuyix"},{"name":"test","_id":"cjuuqqv5z000cucxvyjwv40o4"},{"name":"jvm","_id":"cjuuqqv6g000iucxvs0tddzbz"}],"Data":[],"Page":[],"Post":[{"title":"HashMap常见问答","date":"2019-04-22T08:05:11.000Z","declare":true,"_content":"下文全部源码来自jdk1.7.0_71\n## 1.hashMap的实现原理 ##\nHashMap使用到的数据类型主要就是数组和链表，如图\n![hashMap内部组成](HashMap常见问答/14101204468.jpeg)\n\n## 2.hashMap是怎样实现key-value这样键值对的保存 ##\nHashMap中有一个内部类Entry\n\n    static class Entry<K,V> implements Map.Entry<K,V> {\n\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n\t\t……\n    }\n主要有4个属性，key ,hash,value,指向下一个节点的引用next ，看到这个实体类就明白了，在HashMap中存放的key-value实质是通过实体类Entry来保存的。\n\n<!--more-->\n\n## 3.HashMap的hash()函数 ##\nHash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。**简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。**\n所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。\n两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做**碰撞**。\n\n    /**\n     * Retrieve object hash code and applies a supplemental hash function to the\n     * result hash, which defends against poor quality hash functions.  This is\n     * critical because HashMap uses power-of-two length hash tables, that\n     * otherwise encounter collisions for hashCodes that do not differ\n     * in lower bits. Note: Null keys always map to hash 0, thus index 0.\n     */\n    final int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n\t\t//扰动：把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n上面是java7的HashMap hash()函数，下面是Java8的HashMap hash()函数:\n\n\tstatic final int hash(Object key) {\n    \tint h;\n   \t \treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n\t}\n在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过h & (table.length -1)来得到该对象在数据中保存的位置。\n*（留个坑位，后续把string的hashcode方法补上）*\n## 4.hashMap的put过程 ##\n数组中存储的是最后插入的元素。\n\n首先判断table，也就是数组是否为空，为空的话就去使用inflateTable的方法(这里不多解释)初始化hashmap。\n如果table不为空的话，就判断key是否为空，为空的话就将放到数组的index=0的位置，如果value不为空则返回value值。\n如果key不为空的话，就通过key获取hash值，通过hash值和table的长度与运算获取hashCode值。\n通过hashCode的遍历entry<K,V>的键值对，如果key的hash值相等 并且key.equals(e.key)也相等的话,就将新的value替换掉旧的，返回旧值。\n## 5.hashMap的get过程 ##\n    public V get(Object key) {\n        if (key == null)\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);\n\n        return null == entry ? null : entry.getValue();\n    }\n    private V getForNullKey() {\n        if (size == 0) {\n            return null;\n        }\n        for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n            if (e.key == null) //hashmap的key和value都可以为null\n                return e.value;\n        }\n        return null;\n    }\n\t//根据key获取entry\n    final Entry<K,V> getEntry(Object key) {\n        if (size == 0) {\n            return null;\n        }\n\t\t//1.先获取key的hash值，然后根据hash&table.length(实际用是（hash&table.length-1）)获取到数组元素\n        int hash = (key == null) ? 0 : hash(key);\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];\n             e != null;\n             e = e.next) {\n\t\t\t//2.遍历该元素处的链表  \n            Object k;\n            if (e.hash == hash &&\n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;\n        }\n        return null;\n    }\n## 6.HashMap扩容 ##\nHashMap默认的负载因子大小为0.75，默认容量为1<<4，最大容量为1<<30。\n每当填满75%的空间后将会创建原来HashMap大小的两倍的数组，来重新调整map的大小，并将原来的对象放入新的数组中，整个过程代价会越来越大，因此实际使用时应根据业务量尽量指定HashMap的初始大小\n\n    void resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));\n        table = newTable;\n\t\t//计算下一次的扩容大小\n\t\t//The next size value at which to resize (capacity * load factor).\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n\n    /**\n     * Transfers all entries from current table to newTable.\n     */\n    void transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n## 7.HashMap和Hashtable的区别 ##\n- 1、HashMap是非线程安全的，HashTable是线程安全的。\n- 2、HashMap的键和值都允许有null值存在，而HashTable则不行。\n- 3、因为线程安全的问题，HashMap效率比HashTable的要高。\n- 4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。\n-  一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，或由`Collections.synchronizedMap`方法获得一个线程安全的map,没有必要因为是多线程而用HashTable。\n\n## 8.HashMap的遍历 ##\n第一种:\n\n\tMap map = new HashMap();\n\tIterator iter = map.entrySet().iterator();\n\twhile (iter.hasNext()) {\n\t\tMap.Entry entry = (Map.Entry) iter.next();\n\t\tObject key = entry.getKey();\n\t\tObject val = entry.getValue();\n\t}\n这种效率高,便利了一次entryset，key和value都放到了entry中，以后一定要使用此种方式！\n第二种:\n\n\tMap map = new HashMap();\n\tIterator iter = map.keySet().iterator();\n\twhile (iter.hasNext()) {\n\t\tObject key = iter.next();\n\t\tObject val = map.get(key); //又拿了一次\n\t}\n\n\n----------\n\n","source":"_posts/HashMap常见问答.md","raw":"---\ntitle: HashMap常见问答\ndate: 2019-04-22 16:05:11\ntags: HashMap\ndeclare: true\n---\n下文全部源码来自jdk1.7.0_71\n## 1.hashMap的实现原理 ##\nHashMap使用到的数据类型主要就是数组和链表，如图\n![hashMap内部组成](HashMap常见问答/14101204468.jpeg)\n\n## 2.hashMap是怎样实现key-value这样键值对的保存 ##\nHashMap中有一个内部类Entry\n\n    static class Entry<K,V> implements Map.Entry<K,V> {\n\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n\t\t……\n    }\n主要有4个属性，key ,hash,value,指向下一个节点的引用next ，看到这个实体类就明白了，在HashMap中存放的key-value实质是通过实体类Entry来保存的。\n\n<!--more-->\n\n## 3.HashMap的hash()函数 ##\nHash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。**简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。**\n所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。\n两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做**碰撞**。\n\n    /**\n     * Retrieve object hash code and applies a supplemental hash function to the\n     * result hash, which defends against poor quality hash functions.  This is\n     * critical because HashMap uses power-of-two length hash tables, that\n     * otherwise encounter collisions for hashCodes that do not differ\n     * in lower bits. Note: Null keys always map to hash 0, thus index 0.\n     */\n    final int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        // This function ensures that hashCodes that differ only by\n        // constant multiples at each bit position have a bounded\n        // number of collisions (approximately 8 at default load factor).\n\t\t//扰动：把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n上面是java7的HashMap hash()函数，下面是Java8的HashMap hash()函数:\n\n\tstatic final int hash(Object key) {\n    \tint h;\n   \t \treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n\t}\n在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过h & (table.length -1)来得到该对象在数据中保存的位置。\n*（留个坑位，后续把string的hashcode方法补上）*\n## 4.hashMap的put过程 ##\n数组中存储的是最后插入的元素。\n\n首先判断table，也就是数组是否为空，为空的话就去使用inflateTable的方法(这里不多解释)初始化hashmap。\n如果table不为空的话，就判断key是否为空，为空的话就将放到数组的index=0的位置，如果value不为空则返回value值。\n如果key不为空的话，就通过key获取hash值，通过hash值和table的长度与运算获取hashCode值。\n通过hashCode的遍历entry<K,V>的键值对，如果key的hash值相等 并且key.equals(e.key)也相等的话,就将新的value替换掉旧的，返回旧值。\n## 5.hashMap的get过程 ##\n    public V get(Object key) {\n        if (key == null)\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);\n\n        return null == entry ? null : entry.getValue();\n    }\n    private V getForNullKey() {\n        if (size == 0) {\n            return null;\n        }\n        for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n            if (e.key == null) //hashmap的key和value都可以为null\n                return e.value;\n        }\n        return null;\n    }\n\t//根据key获取entry\n    final Entry<K,V> getEntry(Object key) {\n        if (size == 0) {\n            return null;\n        }\n\t\t//1.先获取key的hash值，然后根据hash&table.length(实际用是（hash&table.length-1）)获取到数组元素\n        int hash = (key == null) ? 0 : hash(key);\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];\n             e != null;\n             e = e.next) {\n\t\t\t//2.遍历该元素处的链表  \n            Object k;\n            if (e.hash == hash &&\n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;\n        }\n        return null;\n    }\n## 6.HashMap扩容 ##\nHashMap默认的负载因子大小为0.75，默认容量为1<<4，最大容量为1<<30。\n每当填满75%的空间后将会创建原来HashMap大小的两倍的数组，来重新调整map的大小，并将原来的对象放入新的数组中，整个过程代价会越来越大，因此实际使用时应根据业务量尽量指定HashMap的初始大小\n\n    void resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));\n        table = newTable;\n\t\t//计算下一次的扩容大小\n\t\t//The next size value at which to resize (capacity * load factor).\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n\n    /**\n     * Transfers all entries from current table to newTable.\n     */\n    void transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n## 7.HashMap和Hashtable的区别 ##\n- 1、HashMap是非线程安全的，HashTable是线程安全的。\n- 2、HashMap的键和值都允许有null值存在，而HashTable则不行。\n- 3、因为线程安全的问题，HashMap效率比HashTable的要高。\n- 4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。\n-  一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，或由`Collections.synchronizedMap`方法获得一个线程安全的map,没有必要因为是多线程而用HashTable。\n\n## 8.HashMap的遍历 ##\n第一种:\n\n\tMap map = new HashMap();\n\tIterator iter = map.entrySet().iterator();\n\twhile (iter.hasNext()) {\n\t\tMap.Entry entry = (Map.Entry) iter.next();\n\t\tObject key = entry.getKey();\n\t\tObject val = entry.getValue();\n\t}\n这种效率高,便利了一次entryset，key和value都放到了entry中，以后一定要使用此种方式！\n第二种:\n\n\tMap map = new HashMap();\n\tIterator iter = map.keySet().iterator();\n\twhile (iter.hasNext()) {\n\t\tObject key = iter.next();\n\t\tObject val = map.get(key); //又拿了一次\n\t}\n\n\n----------\n\n","slug":"HashMap常见问答","published":1,"updated":"2019-04-23T06:27:54.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv4y0000ucxv3wuvf121","content":"<p>下文全部源码来自jdk1.7.0_71</p>\n<h2 id=\"1-hashMap的实现原理\"><a href=\"#1-hashMap的实现原理\" class=\"headerlink\" title=\"1.hashMap的实现原理\"></a>1.hashMap的实现原理</h2><p>HashMap使用到的数据类型主要就是数组和链表，如图<br><img src=\"/2019/04/22/HashMap常见问答/14101204468.jpeg\" alt=\"hashMap内部组成\"></p>\n<h2 id=\"2-hashMap是怎样实现key-value这样键值对的保存\"><a href=\"#2-hashMap是怎样实现key-value这样键值对的保存\" class=\"headerlink\" title=\"2.hashMap是怎样实现key-value这样键值对的保存\"></a>2.hashMap是怎样实现key-value这样键值对的保存</h2><p>HashMap中有一个内部类Entry</p>\n<pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n\n    final K key;\n    V value;\n    Entry&lt;K,V&gt; next;\n    int hash;\n    ……\n}\n</code></pre><p>主要有4个属性，key ,hash,value,指向下一个节点的引用next ，看到这个实体类就明白了，在HashMap中存放的key-value实质是通过实体类Entry来保存的。</p>\n<a id=\"more\"></a>\n<h2 id=\"3-HashMap的hash-函数\"><a href=\"#3-HashMap的hash-函数\" class=\"headerlink\" title=\"3.HashMap的hash()函数\"></a>3.HashMap的hash()函数</h2><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</strong><br>所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。<br>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做<strong>碰撞</strong>。</p>\n<pre><code>/**\n * Retrieve object hash code and applies a supplemental hash function to the\n * result hash, which defends against poor quality hash functions.  This is\n * critical because HashMap uses power-of-two length hash tables, that\n * otherwise encounter collisions for hashCodes that do not differ\n * in lower bits. Note: Null keys always map to hash 0, thus index 0.\n */\nfinal int hash(Object k) {\n    int h = hashSeed;\n    if (0 != h &amp;&amp; k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n\n    h ^= k.hashCode();\n\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n    //扰动：把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响\n    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n}\n</code></pre><p>上面是java7的HashMap hash()函数，下面是Java8的HashMap hash()函数:</p>\n<pre><code>static final int hash(Object key) {\n    int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n</code></pre><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过h &amp; (table.length -1)来得到该对象在数据中保存的位置。<br><em>（留个坑位，后续把string的hashcode方法补上）</em></p>\n<h2 id=\"4-hashMap的put过程\"><a href=\"#4-hashMap的put过程\" class=\"headerlink\" title=\"4.hashMap的put过程\"></a>4.hashMap的put过程</h2><p>数组中存储的是最后插入的元素。</p>\n<p>首先判断table，也就是数组是否为空，为空的话就去使用inflateTable的方法(这里不多解释)初始化hashmap。<br>如果table不为空的话，就判断key是否为空，为空的话就将放到数组的index=0的位置，如果value不为空则返回value值。<br>如果key不为空的话，就通过key获取hash值，通过hash值和table的长度与运算获取hashCode值。<br>通过hashCode的遍历entry&lt;K,V&gt;的键值对，如果key的hash值相等 并且key.equals(e.key)也相等的话,就将新的value替换掉旧的，返回旧值。</p>\n<h2 id=\"5-hashMap的get过程\"><a href=\"#5-hashMap的get过程\" class=\"headerlink\" title=\"5.hashMap的get过程\"></a>5.hashMap的get过程</h2><pre><code>public V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    Entry&lt;K,V&gt; entry = getEntry(key);\n\n    return null == entry ? null : entry.getValue();\n}\nprivate V getForNullKey() {\n    if (size == 0) {\n        return null;\n    }\n    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {\n        if (e.key == null) //hashmap的key和value都可以为null\n            return e.value;\n    }\n    return null;\n}\n//根据key获取entry\nfinal Entry&lt;K,V&gt; getEntry(Object key) {\n    if (size == 0) {\n        return null;\n    }\n    //1.先获取key的hash值，然后根据hash&amp;table.length(实际用是（hash&amp;table.length-1）)获取到数组元素\n    int hash = (key == null) ? 0 : hash(key);\n    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        //2.遍历该元素处的链表  \n        Object k;\n        if (e.hash == hash &amp;&amp;\n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return e;\n    }\n    return null;\n}\n</code></pre><h2 id=\"6-HashMap扩容\"><a href=\"#6-HashMap扩容\" class=\"headerlink\" title=\"6.HashMap扩容\"></a>6.HashMap扩容</h2><p>HashMap默认的负载因子大小为0.75，默认容量为1&lt;&lt;4，最大容量为1&lt;&lt;30。<br>每当填满75%的空间后将会创建原来HashMap大小的两倍的数组，来重新调整map的大小，并将原来的对象放入新的数组中，整个过程代价会越来越大，因此实际使用时应根据业务量尽量指定HashMap的初始大小</p>\n<pre><code>void resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    //计算下一次的扩容大小\n    //The next size value at which to resize (capacity * load factor).\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n\n/**\n * Transfers all entries from current table to newTable.\n */\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    for (Entry&lt;K,V&gt; e : table) {\n        while(null != e) {\n            Entry&lt;K,V&gt; next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n</code></pre><h2 id=\"7-HashMap和Hashtable的区别\"><a href=\"#7-HashMap和Hashtable的区别\" class=\"headerlink\" title=\"7.HashMap和Hashtable的区别\"></a>7.HashMap和Hashtable的区别</h2><ul>\n<li>1、HashMap是非线程安全的，HashTable是线程安全的。</li>\n<li>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</li>\n<li>3、因为线程安全的问题，HashMap效率比HashTable的要高。</li>\n<li>4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</li>\n<li>一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，或由<code>Collections.synchronizedMap</code>方法获得一个线程安全的map,没有必要因为是多线程而用HashTable。</li>\n</ul>\n<h2 id=\"8-HashMap的遍历\"><a href=\"#8-HashMap的遍历\" class=\"headerlink\" title=\"8.HashMap的遍历\"></a>8.HashMap的遍历</h2><p>第一种:</p>\n<pre><code>Map map = new HashMap();\nIterator iter = map.entrySet().iterator();\nwhile (iter.hasNext()) {\n    Map.Entry entry = (Map.Entry) iter.next();\n    Object key = entry.getKey();\n    Object val = entry.getValue();\n}\n</code></pre><p>这种效率高,便利了一次entryset，key和value都放到了entry中，以后一定要使用此种方式！<br>第二种:</p>\n<pre><code>Map map = new HashMap();\nIterator iter = map.keySet().iterator();\nwhile (iter.hasNext()) {\n    Object key = iter.next();\n    Object val = map.get(key); //又拿了一次\n}\n</code></pre><hr>\n","site":{"data":{}},"excerpt":"<p>下文全部源码来自jdk1.7.0_71</p>\n<h2 id=\"1-hashMap的实现原理\"><a href=\"#1-hashMap的实现原理\" class=\"headerlink\" title=\"1.hashMap的实现原理\"></a>1.hashMap的实现原理</h2><p>HashMap使用到的数据类型主要就是数组和链表，如图<br><img src=\"/2019/04/22/HashMap常见问答/14101204468.jpeg\" alt=\"hashMap内部组成\"></p>\n<h2 id=\"2-hashMap是怎样实现key-value这样键值对的保存\"><a href=\"#2-hashMap是怎样实现key-value这样键值对的保存\" class=\"headerlink\" title=\"2.hashMap是怎样实现key-value这样键值对的保存\"></a>2.hashMap是怎样实现key-value这样键值对的保存</h2><p>HashMap中有一个内部类Entry</p>\n<pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n\n    final K key;\n    V value;\n    Entry&lt;K,V&gt; next;\n    int hash;\n    ……\n}\n</code></pre><p>主要有4个属性，key ,hash,value,指向下一个节点的引用next ，看到这个实体类就明白了，在HashMap中存放的key-value实质是通过实体类Entry来保存的。</p>","more":"<h2 id=\"3-HashMap的hash-函数\"><a href=\"#3-HashMap的hash-函数\" class=\"headerlink\" title=\"3.HashMap的hash()函数\"></a>3.HashMap的hash()函数</h2><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</strong><br>所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。<br>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做<strong>碰撞</strong>。</p>\n<pre><code>/**\n * Retrieve object hash code and applies a supplemental hash function to the\n * result hash, which defends against poor quality hash functions.  This is\n * critical because HashMap uses power-of-two length hash tables, that\n * otherwise encounter collisions for hashCodes that do not differ\n * in lower bits. Note: Null keys always map to hash 0, thus index 0.\n */\nfinal int hash(Object k) {\n    int h = hashSeed;\n    if (0 != h &amp;&amp; k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n\n    h ^= k.hashCode();\n\n    // This function ensures that hashCodes that differ only by\n    // constant multiples at each bit position have a bounded\n    // number of collisions (approximately 8 at default load factor).\n    //扰动：把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响\n    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n}\n</code></pre><p>上面是java7的HashMap hash()函数，下面是Java8的HashMap hash()函数:</p>\n<pre><code>static final int hash(Object key) {\n    int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\n</code></pre><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过h &amp; (table.length -1)来得到该对象在数据中保存的位置。<br><em>（留个坑位，后续把string的hashcode方法补上）</em></p>\n<h2 id=\"4-hashMap的put过程\"><a href=\"#4-hashMap的put过程\" class=\"headerlink\" title=\"4.hashMap的put过程\"></a>4.hashMap的put过程</h2><p>数组中存储的是最后插入的元素。</p>\n<p>首先判断table，也就是数组是否为空，为空的话就去使用inflateTable的方法(这里不多解释)初始化hashmap。<br>如果table不为空的话，就判断key是否为空，为空的话就将放到数组的index=0的位置，如果value不为空则返回value值。<br>如果key不为空的话，就通过key获取hash值，通过hash值和table的长度与运算获取hashCode值。<br>通过hashCode的遍历entry&lt;K,V&gt;的键值对，如果key的hash值相等 并且key.equals(e.key)也相等的话,就将新的value替换掉旧的，返回旧值。</p>\n<h2 id=\"5-hashMap的get过程\"><a href=\"#5-hashMap的get过程\" class=\"headerlink\" title=\"5.hashMap的get过程\"></a>5.hashMap的get过程</h2><pre><code>public V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    Entry&lt;K,V&gt; entry = getEntry(key);\n\n    return null == entry ? null : entry.getValue();\n}\nprivate V getForNullKey() {\n    if (size == 0) {\n        return null;\n    }\n    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {\n        if (e.key == null) //hashmap的key和value都可以为null\n            return e.value;\n    }\n    return null;\n}\n//根据key获取entry\nfinal Entry&lt;K,V&gt; getEntry(Object key) {\n    if (size == 0) {\n        return null;\n    }\n    //1.先获取key的hash值，然后根据hash&amp;table.length(实际用是（hash&amp;table.length-1）)获取到数组元素\n    int hash = (key == null) ? 0 : hash(key);\n    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        //2.遍历该元素处的链表  \n        Object k;\n        if (e.hash == hash &amp;&amp;\n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return e;\n    }\n    return null;\n}\n</code></pre><h2 id=\"6-HashMap扩容\"><a href=\"#6-HashMap扩容\" class=\"headerlink\" title=\"6.HashMap扩容\"></a>6.HashMap扩容</h2><p>HashMap默认的负载因子大小为0.75，默认容量为1&lt;&lt;4，最大容量为1&lt;&lt;30。<br>每当填满75%的空间后将会创建原来HashMap大小的两倍的数组，来重新调整map的大小，并将原来的对象放入新的数组中，整个过程代价会越来越大，因此实际使用时应根据业务量尽量指定HashMap的初始大小</p>\n<pre><code>void resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    //计算下一次的扩容大小\n    //The next size value at which to resize (capacity * load factor).\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n\n/**\n * Transfers all entries from current table to newTable.\n */\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    for (Entry&lt;K,V&gt; e : table) {\n        while(null != e) {\n            Entry&lt;K,V&gt; next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n</code></pre><h2 id=\"7-HashMap和Hashtable的区别\"><a href=\"#7-HashMap和Hashtable的区别\" class=\"headerlink\" title=\"7.HashMap和Hashtable的区别\"></a>7.HashMap和Hashtable的区别</h2><ul>\n<li>1、HashMap是非线程安全的，HashTable是线程安全的。</li>\n<li>2、HashMap的键和值都允许有null值存在，而HashTable则不行。</li>\n<li>3、因为线程安全的问题，HashMap效率比HashTable的要高。</li>\n<li>4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</li>\n<li>一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，或由<code>Collections.synchronizedMap</code>方法获得一个线程安全的map,没有必要因为是多线程而用HashTable。</li>\n</ul>\n<h2 id=\"8-HashMap的遍历\"><a href=\"#8-HashMap的遍历\" class=\"headerlink\" title=\"8.HashMap的遍历\"></a>8.HashMap的遍历</h2><p>第一种:</p>\n<pre><code>Map map = new HashMap();\nIterator iter = map.entrySet().iterator();\nwhile (iter.hasNext()) {\n    Map.Entry entry = (Map.Entry) iter.next();\n    Object key = entry.getKey();\n    Object val = entry.getValue();\n}\n</code></pre><p>这种效率高,便利了一次entryset，key和value都放到了entry中，以后一定要使用此种方式！<br>第二种:</p>\n<pre><code>Map map = new HashMap();\nIterator iter = map.keySet().iterator();\nwhile (iter.hasNext()) {\n    Object key = iter.next();\n    Object val = map.get(key); //又拿了一次\n}\n</code></pre><hr>"},{"title":"Java代码的执行顺序","date":"2019-04-23T08:15:36.000Z","declare":true,"_content":"## 概念 ##\n**静态代码块**：在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。\n**构造代码块**：直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。\n**普通代码块**：在方法或语句中出现的{}就称为普通代码块。普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定--“先出现先执行”\n**构造函数**：也称构造器，和类同名，没有返回类型。每个类都有一个默认的构造函数（不带参数），可以不用定义。（void也没有）\n**继承**：在一个现有类型的基础上，通过增加新的方法或者重定义已有方法的方式，产生一个新的类型\n**重载(overload)**：在同一个类里面两个或者是多个方法的方法名相同但是参数不同\n**重写/覆写(override)**：重写也被称为覆写。对一个方法的重写必须发生在具有继承关系的两个类中，即子类对父类方法的重写。它要求两个方法的参数个数和类型以及返回值类型都必须一致，这样才称为方法重写。\n<!--more-->\n## 分析 ##\nA类\n\n\tpublic class A {\n\t    static{\n\t        System.out.println(\"静态代码块---A\");\n\t    }\n\t    {\n\t        System.out.println(\"构造代码块---A\");\n\t    }\n\t    public  A() {\n\t        System.out.println(\"构造方法---A\");\n\t    }\n\t    public static  void test() {\n\t        System.out.println(\"静态方法---A\");\n\t    }\n\t    public void testA() {\n\t        System.out.println(\"普通方法---A\");\n\t    }\n\t    public static void main(String[] args) {\n\t        System.out.println(\"main函数方法---A\");\n\t    }\n\t}\n用另一个类调用下看看：\n        \n\tA.test();\n    System.out.println();\n    A a1 = new A();\n    a1.testA();\n    System.out.println();\n    A a2 = new A();\n    a2.testA();\n结果：\n![执行结果](Java代码的执行顺序/1.png)\n\n由此可见：**每个类的静态代码块只会执行一次，无论你初始化多少次；而构造代码块、构造函数是每初始化一次就执行一次的。**\n执行顺序：**静态代码块>构造代码块>构造方法>main方法（构造代码块和构造方法只有在被初始化的时候才会调用）**\n再看另一例(延用上面的A类)：\n\n\tpublic class B extends  A {\n\t    static{\n\t        System.out.println(\"静态代码块---B\");\n\t    }\n\t    {\n\t        System.out.println(\"构造代码块---B\");\n\t    }\n\t    public  B(int i) {\n\t        System.out.println(\"带参构造方法---B\");\n\t    }\n\t    public  B() {\n\t        System.out.println(\"无参构造方法---B\");\n\t    }\n\t    public static void test() {\n\t        System.out.println(\"静态方法---B\");\n\t    }\n\t    public void testB() {\n\t        System.out.println(\"不带参普通方法---B\");\n\t    }\n\t    public void testB(int i) {\n\t        System.out.println(\"带参普通方法---B\");\n\t    }\n\n\t    public static void main(String[] args) {\n\t        B b = new B();\n\t        System.out.println();\n\t        b = new B(1);\n\t        System.out.println();\n\t        b.testB();\n\t        b.testB(1);\n\t    }\n\t}\n执行结果：\n\n\t静态代码块---A\n\t静态代码块---B\n\t构造代码块---A\n\t无参构造方法---A\n\t构造代码块---B\n\t无参构造方法---B\n\t\n\t构造代码块---A\n\t无参构造方法---A\n\t构造代码块---B\n\t带参构造方法---B\n\t\n\t不带参普通方法---B\n\t带参普通方法---B\n\t\n\tProcess finished with exit code 0\n\n说明：\n1）子类永远会默认继承父类的默认（不带参）的构造函数，子类每初始化一次，必然会调用一次父类的不带参的默认构造器。\n2）当子类和父类都有相同方法声明的函数时，具体调用子类还是父类的方法是看初始化的谁，例如本例中是new B，而与变量类型无关；\n\n所以结论是：\n**父类静态代码块-子类静态代码块-父类构造代码块-父类无参构造方法-子类构造代码块-子类无参构造方法**\n静态代码只会执行一次，构造代码块、构造函数是每初始化一次就执行一次","source":"_posts/Java代码的执行顺序.md","raw":"---\ntitle: Java代码的执行顺序\ndate: 2019/4/23 16:15:36 \ntags: Java\ndeclare: true\n---\n## 概念 ##\n**静态代码块**：在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。\n**构造代码块**：直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。\n**普通代码块**：在方法或语句中出现的{}就称为普通代码块。普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定--“先出现先执行”\n**构造函数**：也称构造器，和类同名，没有返回类型。每个类都有一个默认的构造函数（不带参数），可以不用定义。（void也没有）\n**继承**：在一个现有类型的基础上，通过增加新的方法或者重定义已有方法的方式，产生一个新的类型\n**重载(overload)**：在同一个类里面两个或者是多个方法的方法名相同但是参数不同\n**重写/覆写(override)**：重写也被称为覆写。对一个方法的重写必须发生在具有继承关系的两个类中，即子类对父类方法的重写。它要求两个方法的参数个数和类型以及返回值类型都必须一致，这样才称为方法重写。\n<!--more-->\n## 分析 ##\nA类\n\n\tpublic class A {\n\t    static{\n\t        System.out.println(\"静态代码块---A\");\n\t    }\n\t    {\n\t        System.out.println(\"构造代码块---A\");\n\t    }\n\t    public  A() {\n\t        System.out.println(\"构造方法---A\");\n\t    }\n\t    public static  void test() {\n\t        System.out.println(\"静态方法---A\");\n\t    }\n\t    public void testA() {\n\t        System.out.println(\"普通方法---A\");\n\t    }\n\t    public static void main(String[] args) {\n\t        System.out.println(\"main函数方法---A\");\n\t    }\n\t}\n用另一个类调用下看看：\n        \n\tA.test();\n    System.out.println();\n    A a1 = new A();\n    a1.testA();\n    System.out.println();\n    A a2 = new A();\n    a2.testA();\n结果：\n![执行结果](Java代码的执行顺序/1.png)\n\n由此可见：**每个类的静态代码块只会执行一次，无论你初始化多少次；而构造代码块、构造函数是每初始化一次就执行一次的。**\n执行顺序：**静态代码块>构造代码块>构造方法>main方法（构造代码块和构造方法只有在被初始化的时候才会调用）**\n再看另一例(延用上面的A类)：\n\n\tpublic class B extends  A {\n\t    static{\n\t        System.out.println(\"静态代码块---B\");\n\t    }\n\t    {\n\t        System.out.println(\"构造代码块---B\");\n\t    }\n\t    public  B(int i) {\n\t        System.out.println(\"带参构造方法---B\");\n\t    }\n\t    public  B() {\n\t        System.out.println(\"无参构造方法---B\");\n\t    }\n\t    public static void test() {\n\t        System.out.println(\"静态方法---B\");\n\t    }\n\t    public void testB() {\n\t        System.out.println(\"不带参普通方法---B\");\n\t    }\n\t    public void testB(int i) {\n\t        System.out.println(\"带参普通方法---B\");\n\t    }\n\n\t    public static void main(String[] args) {\n\t        B b = new B();\n\t        System.out.println();\n\t        b = new B(1);\n\t        System.out.println();\n\t        b.testB();\n\t        b.testB(1);\n\t    }\n\t}\n执行结果：\n\n\t静态代码块---A\n\t静态代码块---B\n\t构造代码块---A\n\t无参构造方法---A\n\t构造代码块---B\n\t无参构造方法---B\n\t\n\t构造代码块---A\n\t无参构造方法---A\n\t构造代码块---B\n\t带参构造方法---B\n\t\n\t不带参普通方法---B\n\t带参普通方法---B\n\t\n\tProcess finished with exit code 0\n\n说明：\n1）子类永远会默认继承父类的默认（不带参）的构造函数，子类每初始化一次，必然会调用一次父类的不带参的默认构造器。\n2）当子类和父类都有相同方法声明的函数时，具体调用子类还是父类的方法是看初始化的谁，例如本例中是new B，而与变量类型无关；\n\n所以结论是：\n**父类静态代码块-子类静态代码块-父类构造代码块-父类无参构造方法-子类构造代码块-子类无参构造方法**\n静态代码只会执行一次，构造代码块、构造函数是每初始化一次就执行一次","slug":"Java代码的执行顺序","published":1,"updated":"2019-04-23T08:18:49.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv580001ucxv0pj12h4r","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><strong>静态代码块</strong>：在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。<br><strong>构造代码块</strong>：直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。<br><strong>普通代码块</strong>：在方法或语句中出现的{}就称为普通代码块。普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定–“先出现先执行”<br><strong>构造函数</strong>：也称构造器，和类同名，没有返回类型。每个类都有一个默认的构造函数（不带参数），可以不用定义。（void也没有）<br><strong>继承</strong>：在一个现有类型的基础上，通过增加新的方法或者重定义已有方法的方式，产生一个新的类型<br><strong>重载(overload)</strong>：在同一个类里面两个或者是多个方法的方法名相同但是参数不同<br><strong>重写/覆写(override)</strong>：重写也被称为覆写。对一个方法的重写必须发生在具有继承关系的两个类中，即子类对父类方法的重写。它要求两个方法的参数个数和类型以及返回值类型都必须一致，这样才称为方法重写。<br><a id=\"more\"></a></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>A类</p>\n<pre><code>public class A {\n    static{\n        System.out.println(&quot;静态代码块---A&quot;);\n    }\n    {\n        System.out.println(&quot;构造代码块---A&quot;);\n    }\n    public  A() {\n        System.out.println(&quot;构造方法---A&quot;);\n    }\n    public static  void test() {\n        System.out.println(&quot;静态方法---A&quot;);\n    }\n    public void testA() {\n        System.out.println(&quot;普通方法---A&quot;);\n    }\n    public static void main(String[] args) {\n        System.out.println(&quot;main函数方法---A&quot;);\n    }\n}\n</code></pre><p>用另一个类调用下看看：</p>\n<pre><code>A.test();\nSystem.out.println();\nA a1 = new A();\na1.testA();\nSystem.out.println();\nA a2 = new A();\na2.testA();\n</code></pre><p>结果：<br><img src=\"/2019/04/23/Java代码的执行顺序/1.png\" alt=\"执行结果\"></p>\n<p>由此可见：<strong>每个类的静态代码块只会执行一次，无论你初始化多少次；而构造代码块、构造函数是每初始化一次就执行一次的。</strong><br>执行顺序：<strong>静态代码块&gt;构造代码块&gt;构造方法&gt;main方法（构造代码块和构造方法只有在被初始化的时候才会调用）</strong><br>再看另一例(延用上面的A类)：</p>\n<pre><code>public class B extends  A {\n    static{\n        System.out.println(&quot;静态代码块---B&quot;);\n    }\n    {\n        System.out.println(&quot;构造代码块---B&quot;);\n    }\n    public  B(int i) {\n        System.out.println(&quot;带参构造方法---B&quot;);\n    }\n    public  B() {\n        System.out.println(&quot;无参构造方法---B&quot;);\n    }\n    public static void test() {\n        System.out.println(&quot;静态方法---B&quot;);\n    }\n    public void testB() {\n        System.out.println(&quot;不带参普通方法---B&quot;);\n    }\n    public void testB(int i) {\n        System.out.println(&quot;带参普通方法---B&quot;);\n    }\n\n    public static void main(String[] args) {\n        B b = new B();\n        System.out.println();\n        b = new B(1);\n        System.out.println();\n        b.testB();\n        b.testB(1);\n    }\n}\n</code></pre><p>执行结果：</p>\n<pre><code>静态代码块---A\n静态代码块---B\n构造代码块---A\n无参构造方法---A\n构造代码块---B\n无参构造方法---B\n\n构造代码块---A\n无参构造方法---A\n构造代码块---B\n带参构造方法---B\n\n不带参普通方法---B\n带参普通方法---B\n\nProcess finished with exit code 0\n</code></pre><p>说明：<br>1）子类永远会默认继承父类的默认（不带参）的构造函数，子类每初始化一次，必然会调用一次父类的不带参的默认构造器。<br>2）当子类和父类都有相同方法声明的函数时，具体调用子类还是父类的方法是看初始化的谁，例如本例中是new B，而与变量类型无关；</p>\n<p>所以结论是：<br><strong>父类静态代码块-子类静态代码块-父类构造代码块-父类无参构造方法-子类构造代码块-子类无参构造方法</strong><br>静态代码只会执行一次，构造代码块、构造函数是每初始化一次就执行一次</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p><strong>静态代码块</strong>：在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。<br><strong>构造代码块</strong>：直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。<br><strong>普通代码块</strong>：在方法或语句中出现的{}就称为普通代码块。普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定–“先出现先执行”<br><strong>构造函数</strong>：也称构造器，和类同名，没有返回类型。每个类都有一个默认的构造函数（不带参数），可以不用定义。（void也没有）<br><strong>继承</strong>：在一个现有类型的基础上，通过增加新的方法或者重定义已有方法的方式，产生一个新的类型<br><strong>重载(overload)</strong>：在同一个类里面两个或者是多个方法的方法名相同但是参数不同<br><strong>重写/覆写(override)</strong>：重写也被称为覆写。对一个方法的重写必须发生在具有继承关系的两个类中，即子类对父类方法的重写。它要求两个方法的参数个数和类型以及返回值类型都必须一致，这样才称为方法重写。<br></p>","more":"<p></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>A类</p>\n<pre><code>public class A {\n    static{\n        System.out.println(&quot;静态代码块---A&quot;);\n    }\n    {\n        System.out.println(&quot;构造代码块---A&quot;);\n    }\n    public  A() {\n        System.out.println(&quot;构造方法---A&quot;);\n    }\n    public static  void test() {\n        System.out.println(&quot;静态方法---A&quot;);\n    }\n    public void testA() {\n        System.out.println(&quot;普通方法---A&quot;);\n    }\n    public static void main(String[] args) {\n        System.out.println(&quot;main函数方法---A&quot;);\n    }\n}\n</code></pre><p>用另一个类调用下看看：</p>\n<pre><code>A.test();\nSystem.out.println();\nA a1 = new A();\na1.testA();\nSystem.out.println();\nA a2 = new A();\na2.testA();\n</code></pre><p>结果：<br><img src=\"/2019/04/23/Java代码的执行顺序/1.png\" alt=\"执行结果\"></p>\n<p>由此可见：<strong>每个类的静态代码块只会执行一次，无论你初始化多少次；而构造代码块、构造函数是每初始化一次就执行一次的。</strong><br>执行顺序：<strong>静态代码块&gt;构造代码块&gt;构造方法&gt;main方法（构造代码块和构造方法只有在被初始化的时候才会调用）</strong><br>再看另一例(延用上面的A类)：</p>\n<pre><code>public class B extends  A {\n    static{\n        System.out.println(&quot;静态代码块---B&quot;);\n    }\n    {\n        System.out.println(&quot;构造代码块---B&quot;);\n    }\n    public  B(int i) {\n        System.out.println(&quot;带参构造方法---B&quot;);\n    }\n    public  B() {\n        System.out.println(&quot;无参构造方法---B&quot;);\n    }\n    public static void test() {\n        System.out.println(&quot;静态方法---B&quot;);\n    }\n    public void testB() {\n        System.out.println(&quot;不带参普通方法---B&quot;);\n    }\n    public void testB(int i) {\n        System.out.println(&quot;带参普通方法---B&quot;);\n    }\n\n    public static void main(String[] args) {\n        B b = new B();\n        System.out.println();\n        b = new B(1);\n        System.out.println();\n        b.testB();\n        b.testB(1);\n    }\n}\n</code></pre><p>执行结果：</p>\n<pre><code>静态代码块---A\n静态代码块---B\n构造代码块---A\n无参构造方法---A\n构造代码块---B\n无参构造方法---B\n\n构造代码块---A\n无参构造方法---A\n构造代码块---B\n带参构造方法---B\n\n不带参普通方法---B\n带参普通方法---B\n\nProcess finished with exit code 0\n</code></pre><p>说明：<br>1）子类永远会默认继承父类的默认（不带参）的构造函数，子类每初始化一次，必然会调用一次父类的不带参的默认构造器。<br>2）当子类和父类都有相同方法声明的函数时，具体调用子类还是父类的方法是看初始化的谁，例如本例中是new B，而与变量类型无关；</p>\n<p>所以结论是：<br><strong>父类静态代码块-子类静态代码块-父类构造代码块-父类无参构造方法-子类构造代码块-子类无参构造方法</strong><br>静态代码只会执行一次，构造代码块、构造函数是每初始化一次就执行一次</p>"},{"title":"Java 多线程三大核心","author":"晕","date":"2019-03-05T10:43:00.000Z","declare":true,"_content":"# Java 多线程三大核心\n\n## 原子性\n`Java` 的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。\n\n`JMM` 只是保证了基本的原子性，但类似于 `i++` 之类的操作，看似是原子操作，其实里面涉及到:\n\n- 获取 i 的值。\n- 自增。\n- 再赋值给 i。\n\n这三步操作，所以想要实现 `i++` 这样的原子操作就需要用到 `synchronized` 或者是 `lock` 进行加锁处理。\n\n如果是基础类的自增操作可以使用 `AtomicInteger` 这样的原子类来实现(其本质是利用了 `CPU` 级别的 的 `CAS` 指令来完成的)。\n\n其中用的最多的方法就是: `incrementAndGet()` 以原子的方式自增。\n<!--more-->\n源码如下:\n\n```java\npublic final long incrementAndGet() {\n        for (;;) {\n            long current = get();\n            long next = current + 1;\n            if (compareAndSet(current, next))\n                return next;\n        }\n    }\n```\n\n首先是获得当前的值，然后自增 +1。接着则是最核心的 `compareAndSet() ` 来进行原子更新。\n\n```java\npublic final boolean compareAndSet(long expect, long update) {\n        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);\n    }\n```\n\n其逻辑就是判断当前的值是否被更新过，是否等于 `current`，如果等于就说明没有更新过然后将当前的值更新为 `next`，如果不等于则返回`false` 进入循环，直到更新成功为止。\n\n还有其中的 `get()` 方法也很关键，返回的是当前的值，当前值用了 `volatile` 关键词修饰，保证了内存可见性。\n\n```java\n private volatile int value;\n```\n\n\n## 可见性\n\n现代计算机中，由于 `CPU` 直接从主内存中读取数据的效率不高，所以都会对应的 `CPU` 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。\n\n![](https://ws2.sinaimg.cn/large/006tKfTcly1fmouu3fpokj31ae0osjt1.jpg)\n\n如上图所示。\n\n`volatile` 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。\n\n使用 `volatile` 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。\n\n`synchronized`和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 `volatile` 相比开销较大。\n\n## 顺序性\n以下这段代码:\n\n```java\nint a = 100 ; //1\nint b = 200 ; //2\nint c = a + b ; //3\n```\n\n正常情况下的执行顺序应该是 `1>>2>>3`。但是有时 `JVM` 为了提高整体的效率会进行指令重排导致执行的顺序可能是 `2>>1>>3`。但是 `JVM` 也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。\n\n重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。\n\nJava 中可以使用 `volatile` 来保证顺序性，`synchronized 和 lock` 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。\n\n除了通过 `volatile` 关键字显式的保证顺序之外， `JVM` 还通过 `happen-before` 原则来隐式的保证顺序性。\n\n其中有一条就是适用于 `volatile` 关键字的，针对于 `volatile` 关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。\n\n### volatile 的应用\n\n#### 双重检查锁的单例模式\n\n可以用 `volatile` 实现一个双重检查锁的单例模式：\n\n```java\n    public class Singleton {\n        private static volatile Singleton singleton;\n\n        private Singleton() {\n        }\n\n        public static Singleton getInstance() {\n            if (singleton == null) {\n                synchronized (Singleton.class) {\n                    if (singleton == null) {\n                        singleton = new Singleton();\n                    }\n                }\n            }\n            return singleton;\n        }\n\n    }\n```\n\n这里的 `volatile` 关键字主要是为了防止指令重排。\n如果不用 `volatile` ，`singleton = new Singleton();`，这段代码其实是分为三步：\n\n- 分配内存空间。(1)\n- 初始化对象。(2)\n- 将 `singleton` 对象指向分配的内存地址。(3)\n\n加上 `volatile` 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。\n\n#### 控制停止线程的标记\n\n```java\n    private volatile boolean flag ;\n    private void run(){\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (flag) {\n                    doSomeThing();\n                }\n            }\n        });\n    }\n\n    private void stop(){\n        flag = false ;\n    }\n```\n\n这里如果没有用 volatile 来修饰 flag ，就有可能其中一个线程调用了 `stop()`方法修改了 flag 的值并不会立即刷新到主内存中，导致这个循环并不会立即停止。\n\n这里主要利用的是 `volatile` 的内存可见性。\n\n总结一下:\n- `volatile` 关键字只能保证可见性，顺序性，**不能保证原子性**。","source":"_posts/Java多线程的3个核心.md","raw":"---\ntitle: Java 多线程三大核心\nauthor: 晕\ntags: [Java 多线程]\ncategories: [Java]\ndate: 2019-03-05 18:43:00\ndeclare: true\n---\n# Java 多线程三大核心\n\n## 原子性\n`Java` 的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。\n\n`JMM` 只是保证了基本的原子性，但类似于 `i++` 之类的操作，看似是原子操作，其实里面涉及到:\n\n- 获取 i 的值。\n- 自增。\n- 再赋值给 i。\n\n这三步操作，所以想要实现 `i++` 这样的原子操作就需要用到 `synchronized` 或者是 `lock` 进行加锁处理。\n\n如果是基础类的自增操作可以使用 `AtomicInteger` 这样的原子类来实现(其本质是利用了 `CPU` 级别的 的 `CAS` 指令来完成的)。\n\n其中用的最多的方法就是: `incrementAndGet()` 以原子的方式自增。\n<!--more-->\n源码如下:\n\n```java\npublic final long incrementAndGet() {\n        for (;;) {\n            long current = get();\n            long next = current + 1;\n            if (compareAndSet(current, next))\n                return next;\n        }\n    }\n```\n\n首先是获得当前的值，然后自增 +1。接着则是最核心的 `compareAndSet() ` 来进行原子更新。\n\n```java\npublic final boolean compareAndSet(long expect, long update) {\n        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);\n    }\n```\n\n其逻辑就是判断当前的值是否被更新过，是否等于 `current`，如果等于就说明没有更新过然后将当前的值更新为 `next`，如果不等于则返回`false` 进入循环，直到更新成功为止。\n\n还有其中的 `get()` 方法也很关键，返回的是当前的值，当前值用了 `volatile` 关键词修饰，保证了内存可见性。\n\n```java\n private volatile int value;\n```\n\n\n## 可见性\n\n现代计算机中，由于 `CPU` 直接从主内存中读取数据的效率不高，所以都会对应的 `CPU` 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。\n\n![](https://ws2.sinaimg.cn/large/006tKfTcly1fmouu3fpokj31ae0osjt1.jpg)\n\n如上图所示。\n\n`volatile` 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。\n\n使用 `volatile` 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。\n\n`synchronized`和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 `volatile` 相比开销较大。\n\n## 顺序性\n以下这段代码:\n\n```java\nint a = 100 ; //1\nint b = 200 ; //2\nint c = a + b ; //3\n```\n\n正常情况下的执行顺序应该是 `1>>2>>3`。但是有时 `JVM` 为了提高整体的效率会进行指令重排导致执行的顺序可能是 `2>>1>>3`。但是 `JVM` 也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。\n\n重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。\n\nJava 中可以使用 `volatile` 来保证顺序性，`synchronized 和 lock` 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。\n\n除了通过 `volatile` 关键字显式的保证顺序之外， `JVM` 还通过 `happen-before` 原则来隐式的保证顺序性。\n\n其中有一条就是适用于 `volatile` 关键字的，针对于 `volatile` 关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。\n\n### volatile 的应用\n\n#### 双重检查锁的单例模式\n\n可以用 `volatile` 实现一个双重检查锁的单例模式：\n\n```java\n    public class Singleton {\n        private static volatile Singleton singleton;\n\n        private Singleton() {\n        }\n\n        public static Singleton getInstance() {\n            if (singleton == null) {\n                synchronized (Singleton.class) {\n                    if (singleton == null) {\n                        singleton = new Singleton();\n                    }\n                }\n            }\n            return singleton;\n        }\n\n    }\n```\n\n这里的 `volatile` 关键字主要是为了防止指令重排。\n如果不用 `volatile` ，`singleton = new Singleton();`，这段代码其实是分为三步：\n\n- 分配内存空间。(1)\n- 初始化对象。(2)\n- 将 `singleton` 对象指向分配的内存地址。(3)\n\n加上 `volatile` 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。\n\n#### 控制停止线程的标记\n\n```java\n    private volatile boolean flag ;\n    private void run(){\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (flag) {\n                    doSomeThing();\n                }\n            }\n        });\n    }\n\n    private void stop(){\n        flag = false ;\n    }\n```\n\n这里如果没有用 volatile 来修饰 flag ，就有可能其中一个线程调用了 `stop()`方法修改了 flag 的值并不会立即刷新到主内存中，导致这个循环并不会立即停止。\n\n这里主要利用的是 `volatile` 的内存可见性。\n\n总结一下:\n- `volatile` 关键字只能保证可见性，顺序性，**不能保证原子性**。","slug":"Java多线程的3个核心","published":1,"updated":"2019-04-22T07:20:46.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv5g0003ucxvv6drruyh","content":"<h1 id=\"Java-多线程三大核心\"><a href=\"#Java-多线程三大核心\" class=\"headerlink\" title=\"Java 多线程三大核心\"></a>Java 多线程三大核心</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h2><p><code>Java</code> 的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。</p>\n<p><code>JMM</code> 只是保证了基本的原子性，但类似于 <code>i++</code> 之类的操作，看似是原子操作，其实里面涉及到:</p>\n<ul>\n<li>获取 i 的值。</li>\n<li>自增。</li>\n<li>再赋值给 i。</li>\n</ul>\n<p>这三步操作，所以想要实现 <code>i++</code> 这样的原子操作就需要用到 <code>synchronized</code> 或者是 <code>lock</code> 进行加锁处理。</p>\n<p>如果是基础类的自增操作可以使用 <code>AtomicInteger</code> 这样的原子类来实现(其本质是利用了 <code>CPU</code> 级别的 的 <code>CAS</code> 指令来完成的)。</p>\n<p>其中用的最多的方法就是: <code>incrementAndGet()</code> 以原子的方式自增。<br><a id=\"more\"></a><br>源码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> current = get();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSet(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>首先是获得当前的值，然后自增 +1。接着则是最核心的 <code>compareAndSet()</code> 来进行原子更新。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">long</span> expect, <span class=\"keyword\">long</span> update)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.compareAndSwapLong(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其逻辑就是判断当前的值是否被更新过，是否等于 <code>current</code>，如果等于就说明没有更新过然后将当前的值更新为 <code>next</code>，如果不等于则返回<code>false</code> 进入循环，直到更新成功为止。</p>\n<p>还有其中的 <code>get()</code> 方法也很关键，返回的是当前的值，当前值用了 <code>volatile</code> 关键词修饰，保证了内存可见性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>现代计算机中，由于 <code>CPU</code> 直接从主内存中读取数据的效率不高，所以都会对应的 <code>CPU</code> 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fmouu3fpokj31ae0osjt1.jpg\" alt=\"\"></p>\n<p>如上图所示。</p>\n<p><code>volatile</code> 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。</p>\n<p>使用 <code>volatile</code> 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。</p>\n<p><code>synchronized</code>和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 <code>volatile</code> 相比开销较大。</p>\n<h2 id=\"顺序性\"><a href=\"#顺序性\" class=\"headerlink\" title=\"顺序性\"></a>顺序性</h2><p>以下这段代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">100</span> ; <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">200</span> ; <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a + b ; <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p>正常情况下的执行顺序应该是 <code>1&gt;&gt;2&gt;&gt;3</code>。但是有时 <code>JVM</code> 为了提高整体的效率会进行指令重排导致执行的顺序可能是 <code>2&gt;&gt;1&gt;&gt;3</code>。但是 <code>JVM</code> 也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。</p>\n<p>重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。</p>\n<p>Java 中可以使用 <code>volatile</code> 来保证顺序性，<code>synchronized 和 lock</code> 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。</p>\n<p>除了通过 <code>volatile</code> 关键字显式的保证顺序之外， <code>JVM</code> 还通过 <code>happen-before</code> 原则来隐式的保证顺序性。</p>\n<p>其中有一条就是适用于 <code>volatile</code> 关键字的，针对于 <code>volatile</code> 关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。</p>\n<h3 id=\"volatile-的应用\"><a href=\"#volatile-的应用\" class=\"headerlink\" title=\"volatile 的应用\"></a>volatile 的应用</h3><h4 id=\"双重检查锁的单例模式\"><a href=\"#双重检查锁的单例模式\" class=\"headerlink\" title=\"双重检查锁的单例模式\"></a>双重检查锁的单例模式</h4><p>可以用 <code>volatile</code> 实现一个双重检查锁的单例模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>volatile</code> 关键字主要是为了防止指令重排。<br>如果不用 <code>volatile</code> ，<code>singleton = new Singleton();</code>，这段代码其实是分为三步：</p>\n<ul>\n<li>分配内存空间。(1)</li>\n<li>初始化对象。(2)</li>\n<li>将 <code>singleton</code> 对象指向分配的内存地址。(3)</li>\n</ul>\n<p>加上 <code>volatile</code> 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。</p>\n<h4 id=\"控制停止线程的标记\"><a href=\"#控制停止线程的标记\" class=\"headerlink\" title=\"控制停止线程的标记\"></a>控制停止线程的标记</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag ;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">                doSomeThing();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    flag = <span class=\"keyword\">false</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里如果没有用 volatile 来修饰 flag ，就有可能其中一个线程调用了 <code>stop()</code>方法修改了 flag 的值并不会立即刷新到主内存中，导致这个循环并不会立即停止。</p>\n<p>这里主要利用的是 <code>volatile</code> 的内存可见性。</p>\n<p>总结一下:</p>\n<ul>\n<li><code>volatile</code> 关键字只能保证可见性，顺序性，<strong>不能保证原子性</strong>。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-多线程三大核心\"><a href=\"#Java-多线程三大核心\" class=\"headerlink\" title=\"Java 多线程三大核心\"></a>Java 多线程三大核心</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h2><p><code>Java</code> 的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。</p>\n<p><code>JMM</code> 只是保证了基本的原子性，但类似于 <code>i++</code> 之类的操作，看似是原子操作，其实里面涉及到:</p>\n<ul>\n<li>获取 i 的值。</li>\n<li>自增。</li>\n<li>再赋值给 i。</li>\n</ul>\n<p>这三步操作，所以想要实现 <code>i++</code> 这样的原子操作就需要用到 <code>synchronized</code> 或者是 <code>lock</code> 进行加锁处理。</p>\n<p>如果是基础类的自增操作可以使用 <code>AtomicInteger</code> 这样的原子类来实现(其本质是利用了 <code>CPU</code> 级别的 的 <code>CAS</code> 指令来完成的)。</p>\n<p>其中用的最多的方法就是: <code>incrementAndGet()</code> 以原子的方式自增。<br></p>","more":"<br>源码如下:<p></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> current = get();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSet(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>首先是获得当前的值，然后自增 +1。接着则是最核心的 <code>compareAndSet()</code> 来进行原子更新。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">long</span> expect, <span class=\"keyword\">long</span> update)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.compareAndSwapLong(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其逻辑就是判断当前的值是否被更新过，是否等于 <code>current</code>，如果等于就说明没有更新过然后将当前的值更新为 <code>next</code>，如果不等于则返回<code>false</code> 进入循环，直到更新成功为止。</p>\n<p>还有其中的 <code>get()</code> 方法也很关键，返回的是当前的值，当前值用了 <code>volatile</code> 关键词修饰，保证了内存可见性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>现代计算机中，由于 <code>CPU</code> 直接从主内存中读取数据的效率不高，所以都会对应的 <code>CPU</code> 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fmouu3fpokj31ae0osjt1.jpg\" alt=\"\"></p>\n<p>如上图所示。</p>\n<p><code>volatile</code> 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。</p>\n<p>使用 <code>volatile</code> 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。</p>\n<p><code>synchronized</code>和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 <code>volatile</code> 相比开销较大。</p>\n<h2 id=\"顺序性\"><a href=\"#顺序性\" class=\"headerlink\" title=\"顺序性\"></a>顺序性</h2><p>以下这段代码:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">100</span> ; <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">200</span> ; <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a + b ; <span class=\"comment\">//3</span></span><br></pre></td></tr></table></figure>\n<p>正常情况下的执行顺序应该是 <code>1&gt;&gt;2&gt;&gt;3</code>。但是有时 <code>JVM</code> 为了提高整体的效率会进行指令重排导致执行的顺序可能是 <code>2&gt;&gt;1&gt;&gt;3</code>。但是 <code>JVM</code> 也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。</p>\n<p>重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。</p>\n<p>Java 中可以使用 <code>volatile</code> 来保证顺序性，<code>synchronized 和 lock</code> 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。</p>\n<p>除了通过 <code>volatile</code> 关键字显式的保证顺序之外， <code>JVM</code> 还通过 <code>happen-before</code> 原则来隐式的保证顺序性。</p>\n<p>其中有一条就是适用于 <code>volatile</code> 关键字的，针对于 <code>volatile</code> 关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。</p>\n<h3 id=\"volatile-的应用\"><a href=\"#volatile-的应用\" class=\"headerlink\" title=\"volatile 的应用\"></a>volatile 的应用</h3><h4 id=\"双重检查锁的单例模式\"><a href=\"#双重检查锁的单例模式\" class=\"headerlink\" title=\"双重检查锁的单例模式\"></a>双重检查锁的单例模式</h4><p>可以用 <code>volatile</code> 实现一个双重检查锁的单例模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton singleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>volatile</code> 关键字主要是为了防止指令重排。<br>如果不用 <code>volatile</code> ，<code>singleton = new Singleton();</code>，这段代码其实是分为三步：</p>\n<ul>\n<li>分配内存空间。(1)</li>\n<li>初始化对象。(2)</li>\n<li>将 <code>singleton</code> 对象指向分配的内存地址。(3)</li>\n</ul>\n<p>加上 <code>volatile</code> 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。</p>\n<h4 id=\"控制停止线程的标记\"><a href=\"#控制停止线程的标记\" class=\"headerlink\" title=\"控制停止线程的标记\"></a>控制停止线程的标记</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag ;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (flag) &#123;</span><br><span class=\"line\">                doSomeThing();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    flag = <span class=\"keyword\">false</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里如果没有用 volatile 来修饰 flag ，就有可能其中一个线程调用了 <code>stop()</code>方法修改了 flag 的值并不会立即刷新到主内存中，导致这个循环并不会立即停止。</p>\n<p>这里主要利用的是 <code>volatile</code> 的内存可见性。</p>\n<p>总结一下:</p>\n<ul>\n<li><code>volatile</code> 关键字只能保证可见性，顺序性，<strong>不能保证原子性</strong>。</li>\n</ul>"},{"title":"Shadowsocks Python版一键安装脚本","date":"2019-03-05T13:58:15.000Z","_content":"Shadowsocks Python版一键安装脚本\n原文由【秋水逸冰】发布于https://teddysun.com/342.html\n由于原文需要FQ才能访问，故备份\n本脚本适用环境：\n系统支持：CentOS 6，7，Debian，Ubuntu\n内存要求：≥128M\n日期：2018 年 02 月 07 日\n关于本脚本：\n一键安装 Python 版 Shadowsocks 的最新版。\n友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。\n默认配置：\n服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）\n密码：自己设定（如不设定，默认为 teddysun.com）\n加密方式：自己设定（如不设定，默认为 aes-256-gcm）\n备注：脚本默认创建单用户配置文件，如需配置多用户，安装完毕后参照下面的教程示例手动修改配置文件后重启即可。\n<!--more-->\nShadowsocks for Windows 客户端下载：\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n使用方法：\n使用root用户登录，运行以下命令：\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n安装完成后，脚本提示如下：\nCongratulations, Shadowsocks-python server install completed!\nYour Server IP        :your_server_ip\nYour Server Port      :your_server_port\nYour Password         :your_password\nYour Encryption Method:your_encryption_method\n\nWelcome to visit:https://teddysun.com/342.html\nEnjoy it!\n卸载方法：\n使用root用户登录，运行以下命令：\n./shadowsocks.sh uninstall\n单用户配置文件示例（2015 年 08 月 28 日修正）：\n配置文件路径：/etc/shadowsocks.json\n{\n    \"server\":\"0.0.0.0\",\n    \"server_port\":your_server_port,\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"your_password\",\n    \"timeout\":300,\n    \"method\":\"your_encryption_method\",\n    \"fast_open\": false\n}\n\n多用户多端口配置文件示例（2015 年 08 月 28 日修正）：\n配置文件路径：/etc/shadowsocks.json\n{\n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"your_encryption_method\",\n    \"fast_open\": false\n}\n使用命令（2015 年 08 月 28 日修正）：\n启动：/etc/init.d/shadowsocks start\n停止：/etc/init.d/shadowsocks stop\n重启：/etc/init.d/shadowsocks restart\n状态：/etc/init.d/shadowsocks status\n更多版本 Shadowsocks 服务端一键安装脚本：\nShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）\nCentOS 下 Shadowsocks-libev 一键安装脚本\nDebian 下 Shadowsocks-libev 一键安装脚本\nShadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu）\nShadowsocks 一键安装脚本（四合一）\n参考链接：\nhttps://teddysun.com/339.html\n更新日志\n（2018 年 02 月 07 日）\n1、修改：将默认端口从 8989 改为从 9000-19999 之间随机生成。\n（2017 年 07 月 21 日）\n1、修正：默认加密方式从 aes-256-cfb 改为 aes-256-gcm（官方原版客户端支持该加密方式）；\n2、新增：安装时可选 16 种加密方式的其中之一。如下所示：\naes-256-gcm\naes-192-gcm\naes-128-gcm\naes-256-ctr\naes-192-ctr\naes-128-ctr\naes-256-cfb\naes-192-cfb\naes-128-cfb\ncamellia-128-cfb\ncamellia-192-cfb\ncamellia-256-cfb\nchacha20-ietf-poly1305\nchacha20-ietf\nchacha20\nrc4-md5\n（2016 年 08 月 18 日）\n1、修正：默认安装 Github 上 master 分支最新版本（目前为 2.9.0）。\n2、修正：由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks，而是改为下载 Github 的 master 分支来安装。如果在一段时间后，版本升级了，则先卸载，并再次执行本脚本就可以升级为最新版。\n（2016 年 05 月 12 日）\n1、新增在 CentOS 7 下的防火墙规则设置。\n（2015 年 08 月 28 日）\n1、修正控制脚本 /etc/init.d/shadowsocks 在 CentOS 7 无法查看 status 的问题。\n（2015 年 08 月 01 日）\n1、新增自定义服务器端口功能（如不设定，默认端口为 8989）；\n（2015 年 03 月 10 日）\n1、新增在 Debian、Ubuntu 下的一键安装；\n（2015 年 01 月 21 日）\n1、修正配置文件，与官方给出的 Sample 一致；\n2、修改启动脚本，使用官方给出的后台启动和停止命令。\n（2014 年 10 月 10 日）\n跟作者反馈了多用户多端口问题，作者已更新 Wiki 页面。本教程新增多用户多端口配置文件的 sample 。\n（2014 年 09 月 24 日）\n如何配置多用户？详见：这里\n备注：Shadowsocks 已经支持多用户，在配置文件中增加不同的端口，对应不同的密码即可。\n（2014 年 07 月 12 日）\n1、修正获取公网 IP 时的一个问题。建议不要使用共享公网 IP 的 VPS 来搭建 Shadowsocks 服务。\n（2014 年 05 月 29 日）\n1、增加 chkconfig 配置，实现 service 命令。\n2、配置文件名从 /etc/config.json 改为 /etc/shadowsocks.json（与官方的命名一致）。\n3、配置文件中新增 workers ，值默认为 1（与官方配置同步）。\n（2014 年 05 月 27 日）\n1、修正开机自启动失效的问题。\n2、优化是否后台启动成功的判断逻辑。\n（2014 年 05 月 04 日）\n1、修正对增加防火墙端口逻辑的判断bug，对于已经放行 8989 端口的情况下，则无需再次增加。\n2、修正获取服务器 IP 的判断bug，对于多 IP 的 VPS 或服务器，默认只取第一个公网 IP 写到配置文件（/etc/config.json）里。\n3、加入开机自启动。\n转载请注明：秋水逸冰 » Shadowsocks Python版一键安装脚本 https://teddysun.com/342.html\n","source":"_posts/Shadowsocks-Python版一键安装脚本.md","raw":"---\ntitle: Shadowsocks Python版一键安装脚本\ndate: 2019-03-05 21:58:15\ntags: Shadowsocks\n---\nShadowsocks Python版一键安装脚本\n原文由【秋水逸冰】发布于https://teddysun.com/342.html\n由于原文需要FQ才能访问，故备份\n本脚本适用环境：\n系统支持：CentOS 6，7，Debian，Ubuntu\n内存要求：≥128M\n日期：2018 年 02 月 07 日\n关于本脚本：\n一键安装 Python 版 Shadowsocks 的最新版。\n友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。\n默认配置：\n服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）\n密码：自己设定（如不设定，默认为 teddysun.com）\n加密方式：自己设定（如不设定，默认为 aes-256-gcm）\n备注：脚本默认创建单用户配置文件，如需配置多用户，安装完毕后参照下面的教程示例手动修改配置文件后重启即可。\n<!--more-->\nShadowsocks for Windows 客户端下载：\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n使用方法：\n使用root用户登录，运行以下命令：\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n安装完成后，脚本提示如下：\nCongratulations, Shadowsocks-python server install completed!\nYour Server IP        :your_server_ip\nYour Server Port      :your_server_port\nYour Password         :your_password\nYour Encryption Method:your_encryption_method\n\nWelcome to visit:https://teddysun.com/342.html\nEnjoy it!\n卸载方法：\n使用root用户登录，运行以下命令：\n./shadowsocks.sh uninstall\n单用户配置文件示例（2015 年 08 月 28 日修正）：\n配置文件路径：/etc/shadowsocks.json\n{\n    \"server\":\"0.0.0.0\",\n    \"server_port\":your_server_port,\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"your_password\",\n    \"timeout\":300,\n    \"method\":\"your_encryption_method\",\n    \"fast_open\": false\n}\n\n多用户多端口配置文件示例（2015 年 08 月 28 日修正）：\n配置文件路径：/etc/shadowsocks.json\n{\n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{\n         \"8989\":\"password0\",\n         \"9001\":\"password1\",\n         \"9002\":\"password2\",\n         \"9003\":\"password3\",\n         \"9004\":\"password4\"\n    },\n    \"timeout\":300,\n    \"method\":\"your_encryption_method\",\n    \"fast_open\": false\n}\n使用命令（2015 年 08 月 28 日修正）：\n启动：/etc/init.d/shadowsocks start\n停止：/etc/init.d/shadowsocks stop\n重启：/etc/init.d/shadowsocks restart\n状态：/etc/init.d/shadowsocks status\n更多版本 Shadowsocks 服务端一键安装脚本：\nShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）\nCentOS 下 Shadowsocks-libev 一键安装脚本\nDebian 下 Shadowsocks-libev 一键安装脚本\nShadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu）\nShadowsocks 一键安装脚本（四合一）\n参考链接：\nhttps://teddysun.com/339.html\n更新日志\n（2018 年 02 月 07 日）\n1、修改：将默认端口从 8989 改为从 9000-19999 之间随机生成。\n（2017 年 07 月 21 日）\n1、修正：默认加密方式从 aes-256-cfb 改为 aes-256-gcm（官方原版客户端支持该加密方式）；\n2、新增：安装时可选 16 种加密方式的其中之一。如下所示：\naes-256-gcm\naes-192-gcm\naes-128-gcm\naes-256-ctr\naes-192-ctr\naes-128-ctr\naes-256-cfb\naes-192-cfb\naes-128-cfb\ncamellia-128-cfb\ncamellia-192-cfb\ncamellia-256-cfb\nchacha20-ietf-poly1305\nchacha20-ietf\nchacha20\nrc4-md5\n（2016 年 08 月 18 日）\n1、修正：默认安装 Github 上 master 分支最新版本（目前为 2.9.0）。\n2、修正：由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks，而是改为下载 Github 的 master 分支来安装。如果在一段时间后，版本升级了，则先卸载，并再次执行本脚本就可以升级为最新版。\n（2016 年 05 月 12 日）\n1、新增在 CentOS 7 下的防火墙规则设置。\n（2015 年 08 月 28 日）\n1、修正控制脚本 /etc/init.d/shadowsocks 在 CentOS 7 无法查看 status 的问题。\n（2015 年 08 月 01 日）\n1、新增自定义服务器端口功能（如不设定，默认端口为 8989）；\n（2015 年 03 月 10 日）\n1、新增在 Debian、Ubuntu 下的一键安装；\n（2015 年 01 月 21 日）\n1、修正配置文件，与官方给出的 Sample 一致；\n2、修改启动脚本，使用官方给出的后台启动和停止命令。\n（2014 年 10 月 10 日）\n跟作者反馈了多用户多端口问题，作者已更新 Wiki 页面。本教程新增多用户多端口配置文件的 sample 。\n（2014 年 09 月 24 日）\n如何配置多用户？详见：这里\n备注：Shadowsocks 已经支持多用户，在配置文件中增加不同的端口，对应不同的密码即可。\n（2014 年 07 月 12 日）\n1、修正获取公网 IP 时的一个问题。建议不要使用共享公网 IP 的 VPS 来搭建 Shadowsocks 服务。\n（2014 年 05 月 29 日）\n1、增加 chkconfig 配置，实现 service 命令。\n2、配置文件名从 /etc/config.json 改为 /etc/shadowsocks.json（与官方的命名一致）。\n3、配置文件中新增 workers ，值默认为 1（与官方配置同步）。\n（2014 年 05 月 27 日）\n1、修正开机自启动失效的问题。\n2、优化是否后台启动成功的判断逻辑。\n（2014 年 05 月 04 日）\n1、修正对增加防火墙端口逻辑的判断bug，对于已经放行 8989 端口的情况下，则无需再次增加。\n2、修正获取服务器 IP 的判断bug，对于多 IP 的 VPS 或服务器，默认只取第一个公网 IP 写到配置文件（/etc/config.json）里。\n3、加入开机自启动。\n转载请注明：秋水逸冰 » Shadowsocks Python版一键安装脚本 https://teddysun.com/342.html\n","slug":"Shadowsocks-Python版一键安装脚本","published":1,"updated":"2019-03-07T12:44:59.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv5j0004ucxvhim817gq","content":"<p>Shadowsocks Python版一键安装脚本<br>原文由【秋水逸冰】发布于<a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/342.html</a><br>由于原文需要FQ才能访问，故备份<br>本脚本适用环境：<br>系统支持：CentOS 6，7，Debian，Ubuntu<br>内存要求：≥128M<br>日期：2018 年 02 月 07 日<br>关于本脚本：<br>一键安装 Python 版 Shadowsocks 的最新版。<br>友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。<br>默认配置：<br>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）<br>备注：脚本默认创建单用户配置文件，如需配置多用户，安装完毕后参照下面的教程示例手动修改配置文件后重启即可。<br><a id=\"more\"></a><br>Shadowsocks for Windows 客户端下载：<br><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-windows/releases</a><br>使用方法：<br>使用root用户登录，运行以下命令：<br>wget –no-check-certificate -O shadowsocks.sh <a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</a><br>chmod +x shadowsocks.sh<br>./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log<br>安装完成后，脚本提示如下：<br>Congratulations, Shadowsocks-python server install completed!<br>Your Server IP        :your_server_ip<br>Your Server Port      :your_server_port<br>Your Password         :your_password<br>Your Encryption Method:your_encryption_method</p>\n<p>Welcome to visit:<a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/342.html</a><br>Enjoy it!<br>卸载方法：<br>使用root用户登录，运行以下命令：<br>./shadowsocks.sh uninstall<br>单用户配置文件示例（2015 年 08 月 28 日修正）：<br>配置文件路径：/etc/shadowsocks.json<br>{<br>    “server”:”0.0.0.0”,<br>    “server_port”:your_server_port,<br>    “local_address”:”127.0.0.1”,<br>    “local_port”:1080,<br>    “password”:”your_password”,<br>    “timeout”:300,<br>    “method”:”your_encryption_method”,<br>    “fast_open”: false<br>}</p>\n<p>多用户多端口配置文件示例（2015 年 08 月 28 日修正）：<br>配置文件路径：/etc/shadowsocks.json<br>{<br>    “server”:”0.0.0.0”,<br>    “local_address”:”127.0.0.1”,<br>    “local_port”:1080,<br>    “port_password”:{<br>         “8989”:”password0”,<br>         “9001”:”password1”,<br>         “9002”:”password2”,<br>         “9003”:”password3”,<br>         “9004”:”password4”<br>    },<br>    “timeout”:300,<br>    “method”:”your_encryption_method”,<br>    “fast_open”: false<br>}<br>使用命令（2015 年 08 月 28 日修正）：<br>启动：/etc/init.d/shadowsocks start<br>停止：/etc/init.d/shadowsocks stop<br>重启：/etc/init.d/shadowsocks restart<br>状态：/etc/init.d/shadowsocks status<br>更多版本 Shadowsocks 服务端一键安装脚本：<br>ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）<br>CentOS 下 Shadowsocks-libev 一键安装脚本<br>Debian 下 Shadowsocks-libev 一键安装脚本<br>Shadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu）<br>Shadowsocks 一键安装脚本（四合一）<br>参考链接：<br><a href=\"https://teddysun.com/339.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/339.html</a><br>更新日志<br>（2018 年 02 月 07 日）<br>1、修改：将默认端口从 8989 改为从 9000-19999 之间随机生成。<br>（2017 年 07 月 21 日）<br>1、修正：默认加密方式从 aes-256-cfb 改为 aes-256-gcm（官方原版客户端支持该加密方式）；<br>2、新增：安装时可选 16 种加密方式的其中之一。如下所示：<br>aes-256-gcm<br>aes-192-gcm<br>aes-128-gcm<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>camellia-128-cfb<br>camellia-192-cfb<br>camellia-256-cfb<br>chacha20-ietf-poly1305<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>（2016 年 08 月 18 日）<br>1、修正：默认安装 Github 上 master 分支最新版本（目前为 2.9.0）。<br>2、修正：由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks，而是改为下载 Github 的 master 分支来安装。如果在一段时间后，版本升级了，则先卸载，并再次执行本脚本就可以升级为最新版。<br>（2016 年 05 月 12 日）<br>1、新增在 CentOS 7 下的防火墙规则设置。<br>（2015 年 08 月 28 日）<br>1、修正控制脚本 /etc/init.d/shadowsocks 在 CentOS 7 无法查看 status 的问题。<br>（2015 年 08 月 01 日）<br>1、新增自定义服务器端口功能（如不设定，默认端口为 8989）；<br>（2015 年 03 月 10 日）<br>1、新增在 Debian、Ubuntu 下的一键安装；<br>（2015 年 01 月 21 日）<br>1、修正配置文件，与官方给出的 Sample 一致；<br>2、修改启动脚本，使用官方给出的后台启动和停止命令。<br>（2014 年 10 月 10 日）<br>跟作者反馈了多用户多端口问题，作者已更新 Wiki 页面。本教程新增多用户多端口配置文件的 sample 。<br>（2014 年 09 月 24 日）<br>如何配置多用户？详见：这里<br>备注：Shadowsocks 已经支持多用户，在配置文件中增加不同的端口，对应不同的密码即可。<br>（2014 年 07 月 12 日）<br>1、修正获取公网 IP 时的一个问题。建议不要使用共享公网 IP 的 VPS 来搭建 Shadowsocks 服务。<br>（2014 年 05 月 29 日）<br>1、增加 chkconfig 配置，实现 service 命令。<br>2、配置文件名从 /etc/config.json 改为 /etc/shadowsocks.json（与官方的命名一致）。<br>3、配置文件中新增 workers ，值默认为 1（与官方配置同步）。<br>（2014 年 05 月 27 日）<br>1、修正开机自启动失效的问题。<br>2、优化是否后台启动成功的判断逻辑。<br>（2014 年 05 月 04 日）<br>1、修正对增加防火墙端口逻辑的判断bug，对于已经放行 8989 端口的情况下，则无需再次增加。<br>2、修正获取服务器 IP 的判断bug，对于多 IP 的 VPS 或服务器，默认只取第一个公网 IP 写到配置文件（/etc/config.json）里。<br>3、加入开机自启动。<br>转载请注明：秋水逸冰 » Shadowsocks Python版一键安装脚本 <a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/342.html</a></p>\n","site":{"data":{}},"excerpt":"<p>Shadowsocks Python版一键安装脚本<br>原文由【秋水逸冰】发布于<a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/342.html</a><br>由于原文需要FQ才能访问，故备份<br>本脚本适用环境：<br>系统支持：CentOS 6，7，Debian，Ubuntu<br>内存要求：≥128M<br>日期：2018 年 02 月 07 日<br>关于本脚本：<br>一键安装 Python 版 Shadowsocks 的最新版。<br>友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。<br>默认配置：<br>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，默认为 aes-256-gcm）<br>备注：脚本默认创建单用户配置文件，如需配置多用户，安装完毕后参照下面的教程示例手动修改配置文件后重启即可。<br></p>","more":"<br>Shadowsocks for Windows 客户端下载：<br><a href=\"https://github.com/shadowsocks/shadowsocks-windows/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-windows/releases</a><br>使用方法：<br>使用root用户登录，运行以下命令：<br>wget –no-check-certificate -O shadowsocks.sh <a href=\"https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</a><br>chmod +x shadowsocks.sh<br>./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log<br>安装完成后，脚本提示如下：<br>Congratulations, Shadowsocks-python server install completed!<br>Your Server IP        :your_server_ip<br>Your Server Port      :your_server_port<br>Your Password         :your_password<br>Your Encryption Method:your_encryption_method<p></p>\n<p>Welcome to visit:<a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/342.html</a><br>Enjoy it!<br>卸载方法：<br>使用root用户登录，运行以下命令：<br>./shadowsocks.sh uninstall<br>单用户配置文件示例（2015 年 08 月 28 日修正）：<br>配置文件路径：/etc/shadowsocks.json<br>{<br>    “server”:”0.0.0.0”,<br>    “server_port”:your_server_port,<br>    “local_address”:”127.0.0.1”,<br>    “local_port”:1080,<br>    “password”:”your_password”,<br>    “timeout”:300,<br>    “method”:”your_encryption_method”,<br>    “fast_open”: false<br>}</p>\n<p>多用户多端口配置文件示例（2015 年 08 月 28 日修正）：<br>配置文件路径：/etc/shadowsocks.json<br>{<br>    “server”:”0.0.0.0”,<br>    “local_address”:”127.0.0.1”,<br>    “local_port”:1080,<br>    “port_password”:{<br>         “8989”:”password0”,<br>         “9001”:”password1”,<br>         “9002”:”password2”,<br>         “9003”:”password3”,<br>         “9004”:”password4”<br>    },<br>    “timeout”:300,<br>    “method”:”your_encryption_method”,<br>    “fast_open”: false<br>}<br>使用命令（2015 年 08 月 28 日修正）：<br>启动：/etc/init.d/shadowsocks start<br>停止：/etc/init.d/shadowsocks stop<br>重启：/etc/init.d/shadowsocks restart<br>状态：/etc/init.d/shadowsocks status<br>更多版本 Shadowsocks 服务端一键安装脚本：<br>ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）<br>CentOS 下 Shadowsocks-libev 一键安装脚本<br>Debian 下 Shadowsocks-libev 一键安装脚本<br>Shadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu）<br>Shadowsocks 一键安装脚本（四合一）<br>参考链接：<br><a href=\"https://teddysun.com/339.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/339.html</a><br>更新日志<br>（2018 年 02 月 07 日）<br>1、修改：将默认端口从 8989 改为从 9000-19999 之间随机生成。<br>（2017 年 07 月 21 日）<br>1、修正：默认加密方式从 aes-256-cfb 改为 aes-256-gcm（官方原版客户端支持该加密方式）；<br>2、新增：安装时可选 16 种加密方式的其中之一。如下所示：<br>aes-256-gcm<br>aes-192-gcm<br>aes-128-gcm<br>aes-256-ctr<br>aes-192-ctr<br>aes-128-ctr<br>aes-256-cfb<br>aes-192-cfb<br>aes-128-cfb<br>camellia-128-cfb<br>camellia-192-cfb<br>camellia-256-cfb<br>chacha20-ietf-poly1305<br>chacha20-ietf<br>chacha20<br>rc4-md5<br>（2016 年 08 月 18 日）<br>1、修正：默认安装 Github 上 master 分支最新版本（目前为 2.9.0）。<br>2、修正：由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks，而是改为下载 Github 的 master 分支来安装。如果在一段时间后，版本升级了，则先卸载，并再次执行本脚本就可以升级为最新版。<br>（2016 年 05 月 12 日）<br>1、新增在 CentOS 7 下的防火墙规则设置。<br>（2015 年 08 月 28 日）<br>1、修正控制脚本 /etc/init.d/shadowsocks 在 CentOS 7 无法查看 status 的问题。<br>（2015 年 08 月 01 日）<br>1、新增自定义服务器端口功能（如不设定，默认端口为 8989）；<br>（2015 年 03 月 10 日）<br>1、新增在 Debian、Ubuntu 下的一键安装；<br>（2015 年 01 月 21 日）<br>1、修正配置文件，与官方给出的 Sample 一致；<br>2、修改启动脚本，使用官方给出的后台启动和停止命令。<br>（2014 年 10 月 10 日）<br>跟作者反馈了多用户多端口问题，作者已更新 Wiki 页面。本教程新增多用户多端口配置文件的 sample 。<br>（2014 年 09 月 24 日）<br>如何配置多用户？详见：这里<br>备注：Shadowsocks 已经支持多用户，在配置文件中增加不同的端口，对应不同的密码即可。<br>（2014 年 07 月 12 日）<br>1、修正获取公网 IP 时的一个问题。建议不要使用共享公网 IP 的 VPS 来搭建 Shadowsocks 服务。<br>（2014 年 05 月 29 日）<br>1、增加 chkconfig 配置，实现 service 命令。<br>2、配置文件名从 /etc/config.json 改为 /etc/shadowsocks.json（与官方的命名一致）。<br>3、配置文件中新增 workers ，值默认为 1（与官方配置同步）。<br>（2014 年 05 月 27 日）<br>1、修正开机自启动失效的问题。<br>2、优化是否后台启动成功的判断逻辑。<br>（2014 年 05 月 04 日）<br>1、修正对增加防火墙端口逻辑的判断bug，对于已经放行 8989 端口的情况下，则无需再次增加。<br>2、修正获取服务器 IP 的判断bug，对于多 IP 的 VPS 或服务器，默认只取第一个公网 IP 写到配置文件（/etc/config.json）里。<br>3、加入开机自启动。<br>转载请注明：秋水逸冰 » Shadowsocks Python版一键安装脚本 <a href=\"https://teddysun.com/342.html\" target=\"_blank\" rel=\"noopener\">https://teddysun.com/342.html</a></p>"},{"title":"Sql语句中的DDL、DML、DCL的介绍","date":"2019-03-18T12:38:49.000Z","declare":true,"_content":"\n# 一、DDL #\n\n**DDL is Data Definition Language statements.** 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言\n\n1.**CREATE** - to create objects in the database 创建\n2.**ALTER** - alters the structure of the database 修改\n3.**DROP** - delete objects from the database 删除\n4.**TRUNCATE** - remove all records from a table, including all spaces allocated for the records are removed\n\nTRUNCATE TABLE [Table Name]。\n下面是对Truncate语句在MSSQLServer2000中用法和原理的说明：\nTruncate table 表名 速度快,而且效率高,因为:\nTRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。\nDELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。\nTRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。\n对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。\nTRUNCATE TABLE 不能用于参与了索引视图的表。\n5.**COMMENT** - add comments to the data dictionary 注释\n6.**GRANT** - gives user's access privileges to database 授权\n7.**REVOKE** - withdraw access privileges given with the GRANT command 收回已经授予的权限\n\n\n# 二、DML #\n\n**DML is Data Manipulation Language statements.** 数据操作语言，SQL中处理数据等操作统称为数据操纵语言\n\n1.**SELECT** - retrieve data from the a database 查询\n2.**INSERT** - insert data into a table 添加\n3.**UPDATE** - updates existing data within a table 更新\n4.**DELETE** - deletes all records from a table, the space for the records remain 删除\n5.**CALL** - call a PL/SQL or Java subprogram\n6.**EXPLAIN PLAN** - explain access path to data \nOracle RDBMS执行每一条SQL语句，都必须经过Oracle优化器的评估。所以，了解优化器是如何选择(搜索)路径以及索引是如何被使用的，对优化SQL语句有很大的帮助。Explain可以用来迅速方便地查出对于给定SQL语句中的查询数据是如何得到的即搜索路径(我们通常称为Access Path)。从而使我们选择最优的查询方式达到最大的优化效果。\n7.**LOCK TABLE** - control concurrency 锁，用于控制并发\n\n\n# 三、DCL #\n\n**DCL is Data Control Language statements.** 数据控制语言，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等\n**COMMIT** - save work done 提交\n**SAVEPOINT** - identify a point in a transaction to which you can later roll back 保存点\n**ROLLBACK** - restore database to original since the last COMMIT 回滚\n**SET TRANSACTION **- Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响．","source":"_posts/Sql语句中的DDL、DML、DCL的介绍.md","raw":"---\ntitle: Sql语句中的DDL、DML、DCL的介绍\ndate: 2019-03-18 20:38:49\ntags: sql\ndeclare: true\n---\n\n# 一、DDL #\n\n**DDL is Data Definition Language statements.** 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言\n\n1.**CREATE** - to create objects in the database 创建\n2.**ALTER** - alters the structure of the database 修改\n3.**DROP** - delete objects from the database 删除\n4.**TRUNCATE** - remove all records from a table, including all spaces allocated for the records are removed\n\nTRUNCATE TABLE [Table Name]。\n下面是对Truncate语句在MSSQLServer2000中用法和原理的说明：\nTruncate table 表名 速度快,而且效率高,因为:\nTRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。\nDELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。\nTRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。\n对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。\nTRUNCATE TABLE 不能用于参与了索引视图的表。\n5.**COMMENT** - add comments to the data dictionary 注释\n6.**GRANT** - gives user's access privileges to database 授权\n7.**REVOKE** - withdraw access privileges given with the GRANT command 收回已经授予的权限\n\n\n# 二、DML #\n\n**DML is Data Manipulation Language statements.** 数据操作语言，SQL中处理数据等操作统称为数据操纵语言\n\n1.**SELECT** - retrieve data from the a database 查询\n2.**INSERT** - insert data into a table 添加\n3.**UPDATE** - updates existing data within a table 更新\n4.**DELETE** - deletes all records from a table, the space for the records remain 删除\n5.**CALL** - call a PL/SQL or Java subprogram\n6.**EXPLAIN PLAN** - explain access path to data \nOracle RDBMS执行每一条SQL语句，都必须经过Oracle优化器的评估。所以，了解优化器是如何选择(搜索)路径以及索引是如何被使用的，对优化SQL语句有很大的帮助。Explain可以用来迅速方便地查出对于给定SQL语句中的查询数据是如何得到的即搜索路径(我们通常称为Access Path)。从而使我们选择最优的查询方式达到最大的优化效果。\n7.**LOCK TABLE** - control concurrency 锁，用于控制并发\n\n\n# 三、DCL #\n\n**DCL is Data Control Language statements.** 数据控制语言，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等\n**COMMIT** - save work done 提交\n**SAVEPOINT** - identify a point in a transaction to which you can later roll back 保存点\n**ROLLBACK** - restore database to original since the last COMMIT 回滚\n**SET TRANSACTION **- Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响．","slug":"Sql语句中的DDL、DML、DCL的介绍","published":1,"updated":"2019-04-22T07:20:41.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv5p0006ucxvvzpxv11u","content":"<h1 id=\"一、DDL\"><a href=\"#一、DDL\" class=\"headerlink\" title=\"一、DDL\"></a>一、DDL</h1><p><strong>DDL is Data Definition Language statements.</strong> 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言</p>\n<p>1.<strong>CREATE</strong> - to create objects in the database 创建<br>2.<strong>ALTER</strong> - alters the structure of the database 修改<br>3.<strong>DROP</strong> - delete objects from the database 删除<br>4.<strong>TRUNCATE</strong> - remove all records from a table, including all spaces allocated for the records are removed</p>\n<p>TRUNCATE TABLE [Table Name]。<br>下面是对Truncate语句在MSSQLServer2000中用法和原理的说明：<br>Truncate table 表名 速度快,而且效率高,因为:<br>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。<br>DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。<br>TRUNCATE TABLE 不能用于参与了索引视图的表。<br>5.<strong>COMMENT</strong> - add comments to the data dictionary 注释<br>6.<strong>GRANT</strong> - gives user’s access privileges to database 授权<br>7.<strong>REVOKE</strong> - withdraw access privileges given with the GRANT command 收回已经授予的权限</p>\n<h1 id=\"二、DML\"><a href=\"#二、DML\" class=\"headerlink\" title=\"二、DML\"></a>二、DML</h1><p><strong>DML is Data Manipulation Language statements.</strong> 数据操作语言，SQL中处理数据等操作统称为数据操纵语言</p>\n<p>1.<strong>SELECT</strong> - retrieve data from the a database 查询<br>2.<strong>INSERT</strong> - insert data into a table 添加<br>3.<strong>UPDATE</strong> - updates existing data within a table 更新<br>4.<strong>DELETE</strong> - deletes all records from a table, the space for the records remain 删除<br>5.<strong>CALL</strong> - call a PL/SQL or Java subprogram<br>6.<strong>EXPLAIN PLAN</strong> - explain access path to data<br>Oracle RDBMS执行每一条SQL语句，都必须经过Oracle优化器的评估。所以，了解优化器是如何选择(搜索)路径以及索引是如何被使用的，对优化SQL语句有很大的帮助。Explain可以用来迅速方便地查出对于给定SQL语句中的查询数据是如何得到的即搜索路径(我们通常称为Access Path)。从而使我们选择最优的查询方式达到最大的优化效果。<br>7.<strong>LOCK TABLE</strong> - control concurrency 锁，用于控制并发</p>\n<h1 id=\"三、DCL\"><a href=\"#三、DCL\" class=\"headerlink\" title=\"三、DCL\"></a>三、DCL</h1><p><strong>DCL is Data Control Language statements.</strong> 数据控制语言，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等<br><strong>COMMIT</strong> - save work done 提交<br><strong>SAVEPOINT</strong> - identify a point in a transaction to which you can later roll back 保存点<br><strong>ROLLBACK</strong> - restore database to original since the last COMMIT 回滚<br><strong>SET TRANSACTION </strong>- Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响．</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、DDL\"><a href=\"#一、DDL\" class=\"headerlink\" title=\"一、DDL\"></a>一、DDL</h1><p><strong>DDL is Data Definition Language statements.</strong> 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言</p>\n<p>1.<strong>CREATE</strong> - to create objects in the database 创建<br>2.<strong>ALTER</strong> - alters the structure of the database 修改<br>3.<strong>DROP</strong> - delete objects from the database 删除<br>4.<strong>TRUNCATE</strong> - remove all records from a table, including all spaces allocated for the records are removed</p>\n<p>TRUNCATE TABLE [Table Name]。<br>下面是对Truncate语句在MSSQLServer2000中用法和原理的说明：<br>Truncate table 表名 速度快,而且效率高,因为:<br>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。<br>DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。<br>TRUNCATE TABLE 不能用于参与了索引视图的表。<br>5.<strong>COMMENT</strong> - add comments to the data dictionary 注释<br>6.<strong>GRANT</strong> - gives user’s access privileges to database 授权<br>7.<strong>REVOKE</strong> - withdraw access privileges given with the GRANT command 收回已经授予的权限</p>\n<h1 id=\"二、DML\"><a href=\"#二、DML\" class=\"headerlink\" title=\"二、DML\"></a>二、DML</h1><p><strong>DML is Data Manipulation Language statements.</strong> 数据操作语言，SQL中处理数据等操作统称为数据操纵语言</p>\n<p>1.<strong>SELECT</strong> - retrieve data from the a database 查询<br>2.<strong>INSERT</strong> - insert data into a table 添加<br>3.<strong>UPDATE</strong> - updates existing data within a table 更新<br>4.<strong>DELETE</strong> - deletes all records from a table, the space for the records remain 删除<br>5.<strong>CALL</strong> - call a PL/SQL or Java subprogram<br>6.<strong>EXPLAIN PLAN</strong> - explain access path to data<br>Oracle RDBMS执行每一条SQL语句，都必须经过Oracle优化器的评估。所以，了解优化器是如何选择(搜索)路径以及索引是如何被使用的，对优化SQL语句有很大的帮助。Explain可以用来迅速方便地查出对于给定SQL语句中的查询数据是如何得到的即搜索路径(我们通常称为Access Path)。从而使我们选择最优的查询方式达到最大的优化效果。<br>7.<strong>LOCK TABLE</strong> - control concurrency 锁，用于控制并发</p>\n<h1 id=\"三、DCL\"><a href=\"#三、DCL\" class=\"headerlink\" title=\"三、DCL\"></a>三、DCL</h1><p><strong>DCL is Data Control Language statements.</strong> 数据控制语言，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等<br><strong>COMMIT</strong> - save work done 提交<br><strong>SAVEPOINT</strong> - identify a point in a transaction to which you can later roll back 保存点<br><strong>ROLLBACK</strong> - restore database to original since the last COMMIT 回滚<br><strong>SET TRANSACTION </strong>- Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响．</p>\n"},{"title":"Hello World","declare":true,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!--more-->\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\n====================================\n\n在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：\n\n``` ![你想输入的替代文字](xxxx/图片名.jpg)\n```\n注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。\n\nhexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是<img src=\"2017/02/26/xxxx/图片名.jpg\">，而不是<img src=\"xxxx/图片名.jpg>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: test\ntags: test\ndeclare: true\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!--more-->\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\n====================================\n\n在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：\n\n``` ![你想输入的替代文字](xxxx/图片名.jpg)\n```\n注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。\n\nhexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是<img src=\"2017/02/26/xxxx/图片名.jpg\">，而不是<img src=\"xxxx/图片名.jpg>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-01-24T06:27:53.419Z","updated":"2019-03-18T12:37:59.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv5s0009ucxviius6qsu","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<a id=\"more\"></a>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>====================================</p>\n<p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>\n<pre><code class=\"![你想输入的替代文字](xxxx/图片名.jpg)\">\n</code></pre>\n<p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>\n<p>hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是<img src=\"/2019/01/24/hello-world/2017/02/26/xxxx/图片名.jpg\">，而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>","more":"<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>====================================</p>\n<p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>\n<pre><code class=\"![你想输入的替代文字](xxxx/图片名.jpg)\">\n</code></pre>\n<p>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>\n<p>hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是<img src=\"/2019/01/24/hello-world/2017/02/26/xxxx/图片名.jpg\">，而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"jvm GC策略","date":"2019-04-22T07:41:04.000Z","declare":true,"_content":"GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。\n（1）对新生代的对象的收集称为minor GC；\n（2）对旧生代的对象的收集称为Full GC；\n（3）程序中主动调用System.gc()强制执行的GC为Full GC。\n\n**JVM里的GC(Garbage Collection)的算法有很多种，如标记清除收集器，压缩收集器，分代收集器等等**\n<!--more-->\n 现在比较常用的是分代收集，即将内存分为几个区域，将不同生命周期的对象放在不同区域里:young generation，tenured generation和permanet generation。\n绝大部分的objec被分配在young generation(生命周期短)，并且大部分的object在这里die。当young generation满了之后，将引发minor collection(YGC)。在minor collection后存活的object会被移动到tenured generation(生命周期比较长)。最后，tenured generation满之后触发major collection。major collection（Full gc）会触发整个heap的回收，包括回收young generation。permanet generation区域比较稳定，主要存放classloader信息。\nyoung generation有eden、2个survivor 区域组成。其中一个survivor区域一直是空的，是eden区域和另一个survivor区域在下一次copy collection后活着的objecy的目的地。object在survivo区域被复制直到转移到tenured区。\n我们要尽量减少 Full gc 的次数(tenured generation 一般比较大,收集的时间较长,频繁的Full gc会导致应用的性能收到严重的影响)。\n## 堆内存GC ##\nJVM(采用分代回收的策略)，用较高的频率对年轻的对象(young generation)进行YGC，而对老对象(tenured generation)较少(tenured generation 满了后才进行)进行Full GC。这样就不需要每次GC都将内存中所有对象都检查一遍。\n## 非堆内存不GC ##\nGC不会在主程序运行期对PermGen Space进行清理，所以如果你的应用中有很多CLASS(特别是动态生成类，当然permgen space存放的内容不仅限于类)的话,就很可能出现PermGen Space错误。","source":"_posts/jvm-GC策略.md","raw":"---\ntitle: jvm GC策略\ntags:\n  - jvm内存\ncategories:\n  - jvm\ndate: 2019/4/22 15:41:04 \ndeclare: true\n---\nGC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。\n（1）对新生代的对象的收集称为minor GC；\n（2）对旧生代的对象的收集称为Full GC；\n（3）程序中主动调用System.gc()强制执行的GC为Full GC。\n\n**JVM里的GC(Garbage Collection)的算法有很多种，如标记清除收集器，压缩收集器，分代收集器等等**\n<!--more-->\n 现在比较常用的是分代收集，即将内存分为几个区域，将不同生命周期的对象放在不同区域里:young generation，tenured generation和permanet generation。\n绝大部分的objec被分配在young generation(生命周期短)，并且大部分的object在这里die。当young generation满了之后，将引发minor collection(YGC)。在minor collection后存活的object会被移动到tenured generation(生命周期比较长)。最后，tenured generation满之后触发major collection。major collection（Full gc）会触发整个heap的回收，包括回收young generation。permanet generation区域比较稳定，主要存放classloader信息。\nyoung generation有eden、2个survivor 区域组成。其中一个survivor区域一直是空的，是eden区域和另一个survivor区域在下一次copy collection后活着的objecy的目的地。object在survivo区域被复制直到转移到tenured区。\n我们要尽量减少 Full gc 的次数(tenured generation 一般比较大,收集的时间较长,频繁的Full gc会导致应用的性能收到严重的影响)。\n## 堆内存GC ##\nJVM(采用分代回收的策略)，用较高的频率对年轻的对象(young generation)进行YGC，而对老对象(tenured generation)较少(tenured generation 满了后才进行)进行Full GC。这样就不需要每次GC都将内存中所有对象都检查一遍。\n## 非堆内存不GC ##\nGC不会在主程序运行期对PermGen Space进行清理，所以如果你的应用中有很多CLASS(特别是动态生成类，当然permgen space存放的内容不仅限于类)的话,就很可能出现PermGen Space错误。","slug":"jvm-GC策略","published":1,"updated":"2019-04-22T07:46:58.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv5v000aucxvlm7q7286","content":"<p>GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。<br>（1）对新生代的对象的收集称为minor GC；<br>（2）对旧生代的对象的收集称为Full GC；<br>（3）程序中主动调用System.gc()强制执行的GC为Full GC。</p>\n<p><strong>JVM里的GC(Garbage Collection)的算法有很多种，如标记清除收集器，压缩收集器，分代收集器等等</strong><br><a id=\"more\"></a><br> 现在比较常用的是分代收集，即将内存分为几个区域，将不同生命周期的对象放在不同区域里:young generation，tenured generation和permanet generation。<br>绝大部分的objec被分配在young generation(生命周期短)，并且大部分的object在这里die。当young generation满了之后，将引发minor collection(YGC)。在minor collection后存活的object会被移动到tenured generation(生命周期比较长)。最后，tenured generation满之后触发major collection。major collection（Full gc）会触发整个heap的回收，包括回收young generation。permanet generation区域比较稳定，主要存放classloader信息。<br>young generation有eden、2个survivor 区域组成。其中一个survivor区域一直是空的，是eden区域和另一个survivor区域在下一次copy collection后活着的objecy的目的地。object在survivo区域被复制直到转移到tenured区。<br>我们要尽量减少 Full gc 的次数(tenured generation 一般比较大,收集的时间较长,频繁的Full gc会导致应用的性能收到严重的影响)。</p>\n<h2 id=\"堆内存GC\"><a href=\"#堆内存GC\" class=\"headerlink\" title=\"堆内存GC\"></a>堆内存GC</h2><p>JVM(采用分代回收的策略)，用较高的频率对年轻的对象(young generation)进行YGC，而对老对象(tenured generation)较少(tenured generation 满了后才进行)进行Full GC。这样就不需要每次GC都将内存中所有对象都检查一遍。</p>\n<h2 id=\"非堆内存不GC\"><a href=\"#非堆内存不GC\" class=\"headerlink\" title=\"非堆内存不GC\"></a>非堆内存不GC</h2><p>GC不会在主程序运行期对PermGen Space进行清理，所以如果你的应用中有很多CLASS(特别是动态生成类，当然permgen space存放的内容不仅限于类)的话,就很可能出现PermGen Space错误。</p>\n","site":{"data":{}},"excerpt":"<p>GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。<br>（1）对新生代的对象的收集称为minor GC；<br>（2）对旧生代的对象的收集称为Full GC；<br>（3）程序中主动调用System.gc()强制执行的GC为Full GC。</p>\n<p><strong>JVM里的GC(Garbage Collection)的算法有很多种，如标记清除收集器，压缩收集器，分代收集器等等</strong><br></p>","more":"<br> 现在比较常用的是分代收集，即将内存分为几个区域，将不同生命周期的对象放在不同区域里:young generation，tenured generation和permanet generation。<br>绝大部分的objec被分配在young generation(生命周期短)，并且大部分的object在这里die。当young generation满了之后，将引发minor collection(YGC)。在minor collection后存活的object会被移动到tenured generation(生命周期比较长)。最后，tenured generation满之后触发major collection。major collection（Full gc）会触发整个heap的回收，包括回收young generation。permanet generation区域比较稳定，主要存放classloader信息。<br>young generation有eden、2个survivor 区域组成。其中一个survivor区域一直是空的，是eden区域和另一个survivor区域在下一次copy collection后活着的objecy的目的地。object在survivo区域被复制直到转移到tenured区。<br>我们要尽量减少 Full gc 的次数(tenured generation 一般比较大,收集的时间较长,频繁的Full gc会导致应用的性能收到严重的影响)。<p></p>\n<h2 id=\"堆内存GC\"><a href=\"#堆内存GC\" class=\"headerlink\" title=\"堆内存GC\"></a>堆内存GC</h2><p>JVM(采用分代回收的策略)，用较高的频率对年轻的对象(young generation)进行YGC，而对老对象(tenured generation)较少(tenured generation 满了后才进行)进行Full GC。这样就不需要每次GC都将内存中所有对象都检查一遍。</p>\n<h2 id=\"非堆内存不GC\"><a href=\"#非堆内存不GC\" class=\"headerlink\" title=\"非堆内存不GC\"></a>非堆内存不GC</h2><p>GC不会在主程序运行期对PermGen Space进行清理，所以如果你的应用中有很多CLASS(特别是动态生成类，当然permgen space存放的内容不仅限于类)的话,就很可能出现PermGen Space错误。</p>"},{"title":"jvm内存组成","date":"2019-04-22T07:26:29.000Z","declare":true,"_content":"# JVM的内存区域是怎么划分的？ #\n\n下面这张图，反映了运行中的Java进程内存占用情况：\n\n![jvm内存组成](jvm内存组成/memory-area1.png)\n\n<!--more-->\n首先是**程序计数器（Program Counter Register)**，在JVM规范中，每个线程都有自己的程序计数器。这是一块比较小的内存空间，存储当前线程正在执行的Java方法的JVM指令地址，即字节码的行号。如果正在执行Native方法，则这个计数器为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的内存区域。\n\n第二，**Java虚拟机栈(Java Virtal Machine Stack)**，同样也是属于线程私有区域，每个线程在创建的时候都会创建一个虚拟机栈，生命周期与线程一致，线程退出时，线程的虚拟机栈也回收。虚拟机栈内部保持一个个的栈帧，每次方法调用都会进行压栈，JVM对栈帧的操作只有出栈和压栈两种，方法调用结束时会进行出栈操作。\n\n该区域存储着局部变量表，编译时期可知的各种基本类型数据、对象引用、方法出口等信息。\n\n第三，**本地方法栈（Native Method Stack）**与虚拟机栈类似，本地方法栈是在调用本地方法时使用的栈，每个线程都有一个本地方法栈。\n\n第四，**堆（Heap）**,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。\n\n第五，**方法区（Method Area)**。方法区与堆一样，也是所有的线程所共享，存储被虚拟机加载的元（Meta）数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据。这里需要注意的是运行时常量池也在方法区中。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。由于早期HotSpot JVM的实现，将CG分代收集拓展到了方法区，因此很多人会将方法区称为永久代。Oracle JDK8中已永久代移除永久代，同时增加了元数据区（Metaspace）。\n\n第六，**运行时常量池（Run-Time Constant Pool)**，这是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。\n\n在Class文件中，除了有类的版本、方法、字段、接口等描述信息外，还有一项信息是常量池。每个Class文件的头四个字节称为Magic Number，它的作用是确定这是否是一个可以被虚拟机接受的文件；接着的四个字节存储的是Class文件的版本号。紧挨着版本号之后的，就是常量池入口了。常量池主要存放两大类常量：\n\n  ● 字面量（Literal），如文本字符串、final常量值\n  ● 符号引用，存放了与编译相关的一些常量，因为Java不像C++那样有连接的过程，因此字段方法这些符号引用在运行期就需要进行转换，以便得到真正的内存入口地址。\n\nclass文件中的常量池，也称为静态常量池，JVM虚拟机完成类装载操作后，会把静态常量池加载到内存中，存放在运行时常量池。\n\n第七，**直接内存（Direct Memory）**，直接内存并不属于Java规范规定的属于Java虚拟机运行时数据区的一部分。Java的NIO可以使用Native方法直接在java堆外分配内存，使用DirectByteBuffer对象作为这个堆外内存的引用。\n\n\n\n**OOM可能发生在哪些区域上？**\n\n根据javadoc的描述，OOM是指JVM的内存不够用了，同时垃圾收集器也无法提供更多的内存。从描述中可以看出，在JVM抛出OutOfMemoryError之前，垃圾收集器一般会出马先尝试回收内存。\n\n从上面分析的Java数据区来看，除了程序计数器不会发生OOM外，哪些区域会发生OOM的情况呢？\n\n**第一，堆内存。**堆内存不足是最常见的发送OOM的原因之一，如果在堆中没有内存完成对象实例的分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常。当前主流的JVM可以通过-Xmx和-Xms来控制堆内存的大小，发生堆上OOM的可能是存在内存泄露，也可能是堆大小分配不合理。\n\n**第二，Java虚拟机栈和本地方法栈**，这两个区域的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务，在内存分配异常上是相同的。在JVM规范中，对Java虚拟机栈规定了两种异常：1.如果线程请求的栈大于所分配的栈大小，则抛出StackOverFlowError错误，比如进行了一个不会停止的递归调用；2. 如果虚拟机栈是可以动态拓展的，拓展时无法申请到足够的内存，则抛出OutOfMemoryError错误。\n\n**第三，直接内存**。直接内存虽然不是虚拟机运行时数据区的一部分，但既然是内存，就会受到物理内存的限制。在JDK1.4中引入的NIO使用Native函数库在堆外内存上直接分配内存，但直接内存不足时，也会导致OOM。\n\n**第四，方法区。**随着Metaspace元数据区的引入，方法区的OOM错误信息也变成了“java.lang.OutOfMemoryError:Metaspace”。对于旧版本的Oracle JDK，由于永久代的大小有限，而JVM对永久代的垃圾回收并不积极，如果往永久代不断写入数据，例如String.Intern()的调用，在永久代占用太多空间导致内存不足，也会出现OOM的问题，对应的错误信为“java.lang.OutOfMemoryError:PermGen space”","source":"_posts/jvm内存组成.md","raw":"---\ntitle: jvm内存组成\ntags:\n  - jvm内存\ncategories:\n  - jvm\ndate: 2019/4/22 15:26:29 \ndeclare: true\n---\n# JVM的内存区域是怎么划分的？ #\n\n下面这张图，反映了运行中的Java进程内存占用情况：\n\n![jvm内存组成](jvm内存组成/memory-area1.png)\n\n<!--more-->\n首先是**程序计数器（Program Counter Register)**，在JVM规范中，每个线程都有自己的程序计数器。这是一块比较小的内存空间，存储当前线程正在执行的Java方法的JVM指令地址，即字节码的行号。如果正在执行Native方法，则这个计数器为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的内存区域。\n\n第二，**Java虚拟机栈(Java Virtal Machine Stack)**，同样也是属于线程私有区域，每个线程在创建的时候都会创建一个虚拟机栈，生命周期与线程一致，线程退出时，线程的虚拟机栈也回收。虚拟机栈内部保持一个个的栈帧，每次方法调用都会进行压栈，JVM对栈帧的操作只有出栈和压栈两种，方法调用结束时会进行出栈操作。\n\n该区域存储着局部变量表，编译时期可知的各种基本类型数据、对象引用、方法出口等信息。\n\n第三，**本地方法栈（Native Method Stack）**与虚拟机栈类似，本地方法栈是在调用本地方法时使用的栈，每个线程都有一个本地方法栈。\n\n第四，**堆（Heap）**,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。\n\n第五，**方法区（Method Area)**。方法区与堆一样，也是所有的线程所共享，存储被虚拟机加载的元（Meta）数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据。这里需要注意的是运行时常量池也在方法区中。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。由于早期HotSpot JVM的实现，将CG分代收集拓展到了方法区，因此很多人会将方法区称为永久代。Oracle JDK8中已永久代移除永久代，同时增加了元数据区（Metaspace）。\n\n第六，**运行时常量池（Run-Time Constant Pool)**，这是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。\n\n在Class文件中，除了有类的版本、方法、字段、接口等描述信息外，还有一项信息是常量池。每个Class文件的头四个字节称为Magic Number，它的作用是确定这是否是一个可以被虚拟机接受的文件；接着的四个字节存储的是Class文件的版本号。紧挨着版本号之后的，就是常量池入口了。常量池主要存放两大类常量：\n\n  ● 字面量（Literal），如文本字符串、final常量值\n  ● 符号引用，存放了与编译相关的一些常量，因为Java不像C++那样有连接的过程，因此字段方法这些符号引用在运行期就需要进行转换，以便得到真正的内存入口地址。\n\nclass文件中的常量池，也称为静态常量池，JVM虚拟机完成类装载操作后，会把静态常量池加载到内存中，存放在运行时常量池。\n\n第七，**直接内存（Direct Memory）**，直接内存并不属于Java规范规定的属于Java虚拟机运行时数据区的一部分。Java的NIO可以使用Native方法直接在java堆外分配内存，使用DirectByteBuffer对象作为这个堆外内存的引用。\n\n\n\n**OOM可能发生在哪些区域上？**\n\n根据javadoc的描述，OOM是指JVM的内存不够用了，同时垃圾收集器也无法提供更多的内存。从描述中可以看出，在JVM抛出OutOfMemoryError之前，垃圾收集器一般会出马先尝试回收内存。\n\n从上面分析的Java数据区来看，除了程序计数器不会发生OOM外，哪些区域会发生OOM的情况呢？\n\n**第一，堆内存。**堆内存不足是最常见的发送OOM的原因之一，如果在堆中没有内存完成对象实例的分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常。当前主流的JVM可以通过-Xmx和-Xms来控制堆内存的大小，发生堆上OOM的可能是存在内存泄露，也可能是堆大小分配不合理。\n\n**第二，Java虚拟机栈和本地方法栈**，这两个区域的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务，在内存分配异常上是相同的。在JVM规范中，对Java虚拟机栈规定了两种异常：1.如果线程请求的栈大于所分配的栈大小，则抛出StackOverFlowError错误，比如进行了一个不会停止的递归调用；2. 如果虚拟机栈是可以动态拓展的，拓展时无法申请到足够的内存，则抛出OutOfMemoryError错误。\n\n**第三，直接内存**。直接内存虽然不是虚拟机运行时数据区的一部分，但既然是内存，就会受到物理内存的限制。在JDK1.4中引入的NIO使用Native函数库在堆外内存上直接分配内存，但直接内存不足时，也会导致OOM。\n\n**第四，方法区。**随着Metaspace元数据区的引入，方法区的OOM错误信息也变成了“java.lang.OutOfMemoryError:Metaspace”。对于旧版本的Oracle JDK，由于永久代的大小有限，而JVM对永久代的垃圾回收并不积极，如果往永久代不断写入数据，例如String.Intern()的调用，在永久代占用太多空间导致内存不足，也会出现OOM的问题，对应的错误信为“java.lang.OutOfMemoryError:PermGen space”","slug":"jvm内存组成","published":1,"updated":"2019-04-22T07:38:26.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv61000ducxv2ygci3fb","content":"<h1 id=\"JVM的内存区域是怎么划分的？\"><a href=\"#JVM的内存区域是怎么划分的？\" class=\"headerlink\" title=\"JVM的内存区域是怎么划分的？\"></a>JVM的内存区域是怎么划分的？</h1><p>下面这张图，反映了运行中的Java进程内存占用情况：</p>\n<p><img src=\"/2019/04/22/jvm内存组成/memory-area1.png\" alt=\"jvm内存组成\"></p>\n<a id=\"more\"></a>\n<p>首先是<strong>程序计数器（Program Counter Register)</strong>，在JVM规范中，每个线程都有自己的程序计数器。这是一块比较小的内存空间，存储当前线程正在执行的Java方法的JVM指令地址，即字节码的行号。如果正在执行Native方法，则这个计数器为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的内存区域。</p>\n<p>第二，<strong>Java虚拟机栈(Java Virtal Machine Stack)</strong>，同样也是属于线程私有区域，每个线程在创建的时候都会创建一个虚拟机栈，生命周期与线程一致，线程退出时，线程的虚拟机栈也回收。虚拟机栈内部保持一个个的栈帧，每次方法调用都会进行压栈，JVM对栈帧的操作只有出栈和压栈两种，方法调用结束时会进行出栈操作。</p>\n<p>该区域存储着局部变量表，编译时期可知的各种基本类型数据、对象引用、方法出口等信息。</p>\n<p>第三，<strong>本地方法栈（Native Method Stack）</strong>与虚拟机栈类似，本地方法栈是在调用本地方法时使用的栈，每个线程都有一个本地方法栈。</p>\n<p>第四，<strong>堆（Heap）</strong>,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。</p>\n<p>第五，<strong>方法区（Method Area)</strong>。方法区与堆一样，也是所有的线程所共享，存储被虚拟机加载的元（Meta）数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据。这里需要注意的是运行时常量池也在方法区中。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。由于早期HotSpot JVM的实现，将CG分代收集拓展到了方法区，因此很多人会将方法区称为永久代。Oracle JDK8中已永久代移除永久代，同时增加了元数据区（Metaspace）。</p>\n<p>第六，<strong>运行时常量池（Run-Time Constant Pool)</strong>，这是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。</p>\n<p>在Class文件中，除了有类的版本、方法、字段、接口等描述信息外，还有一项信息是常量池。每个Class文件的头四个字节称为Magic Number，它的作用是确定这是否是一个可以被虚拟机接受的文件；接着的四个字节存储的是Class文件的版本号。紧挨着版本号之后的，就是常量池入口了。常量池主要存放两大类常量：</p>\n<p>  ● 字面量（Literal），如文本字符串、final常量值<br>  ● 符号引用，存放了与编译相关的一些常量，因为Java不像C++那样有连接的过程，因此字段方法这些符号引用在运行期就需要进行转换，以便得到真正的内存入口地址。</p>\n<p>class文件中的常量池，也称为静态常量池，JVM虚拟机完成类装载操作后，会把静态常量池加载到内存中，存放在运行时常量池。</p>\n<p>第七，<strong>直接内存（Direct Memory）</strong>，直接内存并不属于Java规范规定的属于Java虚拟机运行时数据区的一部分。Java的NIO可以使用Native方法直接在java堆外分配内存，使用DirectByteBuffer对象作为这个堆外内存的引用。</p>\n<p><strong>OOM可能发生在哪些区域上？</strong></p>\n<p>根据javadoc的描述，OOM是指JVM的内存不够用了，同时垃圾收集器也无法提供更多的内存。从描述中可以看出，在JVM抛出OutOfMemoryError之前，垃圾收集器一般会出马先尝试回收内存。</p>\n<p>从上面分析的Java数据区来看，除了程序计数器不会发生OOM外，哪些区域会发生OOM的情况呢？</p>\n<p><strong>第一，堆内存。</strong>堆内存不足是最常见的发送OOM的原因之一，如果在堆中没有内存完成对象实例的分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常。当前主流的JVM可以通过-Xmx和-Xms来控制堆内存的大小，发生堆上OOM的可能是存在内存泄露，也可能是堆大小分配不合理。</p>\n<p><strong>第二，Java虚拟机栈和本地方法栈</strong>，这两个区域的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务，在内存分配异常上是相同的。在JVM规范中，对Java虚拟机栈规定了两种异常：1.如果线程请求的栈大于所分配的栈大小，则抛出StackOverFlowError错误，比如进行了一个不会停止的递归调用；2. 如果虚拟机栈是可以动态拓展的，拓展时无法申请到足够的内存，则抛出OutOfMemoryError错误。</p>\n<p><strong>第三，直接内存</strong>。直接内存虽然不是虚拟机运行时数据区的一部分，但既然是内存，就会受到物理内存的限制。在JDK1.4中引入的NIO使用Native函数库在堆外内存上直接分配内存，但直接内存不足时，也会导致OOM。</p>\n<p><strong>第四，方法区。</strong>随着Metaspace元数据区的引入，方法区的OOM错误信息也变成了“java.lang.OutOfMemoryError:Metaspace”。对于旧版本的Oracle JDK，由于永久代的大小有限，而JVM对永久代的垃圾回收并不积极，如果往永久代不断写入数据，例如String.Intern()的调用，在永久代占用太多空间导致内存不足，也会出现OOM的问题，对应的错误信为“java.lang.OutOfMemoryError:PermGen space”</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JVM的内存区域是怎么划分的？\"><a href=\"#JVM的内存区域是怎么划分的？\" class=\"headerlink\" title=\"JVM的内存区域是怎么划分的？\"></a>JVM的内存区域是怎么划分的？</h1><p>下面这张图，反映了运行中的Java进程内存占用情况：</p>\n<p><img src=\"/2019/04/22/jvm内存组成/memory-area1.png\" alt=\"jvm内存组成\"></p>","more":"<p>首先是<strong>程序计数器（Program Counter Register)</strong>，在JVM规范中，每个线程都有自己的程序计数器。这是一块比较小的内存空间，存储当前线程正在执行的Java方法的JVM指令地址，即字节码的行号。如果正在执行Native方法，则这个计数器为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的内存区域。</p>\n<p>第二，<strong>Java虚拟机栈(Java Virtal Machine Stack)</strong>，同样也是属于线程私有区域，每个线程在创建的时候都会创建一个虚拟机栈，生命周期与线程一致，线程退出时，线程的虚拟机栈也回收。虚拟机栈内部保持一个个的栈帧，每次方法调用都会进行压栈，JVM对栈帧的操作只有出栈和压栈两种，方法调用结束时会进行出栈操作。</p>\n<p>该区域存储着局部变量表，编译时期可知的各种基本类型数据、对象引用、方法出口等信息。</p>\n<p>第三，<strong>本地方法栈（Native Method Stack）</strong>与虚拟机栈类似，本地方法栈是在调用本地方法时使用的栈，每个线程都有一个本地方法栈。</p>\n<p>第四，<strong>堆（Heap）</strong>,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。</p>\n<p>第五，<strong>方法区（Method Area)</strong>。方法区与堆一样，也是所有的线程所共享，存储被虚拟机加载的元（Meta）数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据。这里需要注意的是运行时常量池也在方法区中。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。由于早期HotSpot JVM的实现，将CG分代收集拓展到了方法区，因此很多人会将方法区称为永久代。Oracle JDK8中已永久代移除永久代，同时增加了元数据区（Metaspace）。</p>\n<p>第六，<strong>运行时常量池（Run-Time Constant Pool)</strong>，这是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。</p>\n<p>在Class文件中，除了有类的版本、方法、字段、接口等描述信息外，还有一项信息是常量池。每个Class文件的头四个字节称为Magic Number，它的作用是确定这是否是一个可以被虚拟机接受的文件；接着的四个字节存储的是Class文件的版本号。紧挨着版本号之后的，就是常量池入口了。常量池主要存放两大类常量：</p>\n<p>  ● 字面量（Literal），如文本字符串、final常量值<br>  ● 符号引用，存放了与编译相关的一些常量，因为Java不像C++那样有连接的过程，因此字段方法这些符号引用在运行期就需要进行转换，以便得到真正的内存入口地址。</p>\n<p>class文件中的常量池，也称为静态常量池，JVM虚拟机完成类装载操作后，会把静态常量池加载到内存中，存放在运行时常量池。</p>\n<p>第七，<strong>直接内存（Direct Memory）</strong>，直接内存并不属于Java规范规定的属于Java虚拟机运行时数据区的一部分。Java的NIO可以使用Native方法直接在java堆外分配内存，使用DirectByteBuffer对象作为这个堆外内存的引用。</p>\n<p><strong>OOM可能发生在哪些区域上？</strong></p>\n<p>根据javadoc的描述，OOM是指JVM的内存不够用了，同时垃圾收集器也无法提供更多的内存。从描述中可以看出，在JVM抛出OutOfMemoryError之前，垃圾收集器一般会出马先尝试回收内存。</p>\n<p>从上面分析的Java数据区来看，除了程序计数器不会发生OOM外，哪些区域会发生OOM的情况呢？</p>\n<p><strong>第一，堆内存。</strong>堆内存不足是最常见的发送OOM的原因之一，如果在堆中没有内存完成对象实例的分配，并且堆无法再扩展时，将抛出OutOfMemoryError异常。当前主流的JVM可以通过-Xmx和-Xms来控制堆内存的大小，发生堆上OOM的可能是存在内存泄露，也可能是堆大小分配不合理。</p>\n<p><strong>第二，Java虚拟机栈和本地方法栈</strong>，这两个区域的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务，在内存分配异常上是相同的。在JVM规范中，对Java虚拟机栈规定了两种异常：1.如果线程请求的栈大于所分配的栈大小，则抛出StackOverFlowError错误，比如进行了一个不会停止的递归调用；2. 如果虚拟机栈是可以动态拓展的，拓展时无法申请到足够的内存，则抛出OutOfMemoryError错误。</p>\n<p><strong>第三，直接内存</strong>。直接内存虽然不是虚拟机运行时数据区的一部分，但既然是内存，就会受到物理内存的限制。在JDK1.4中引入的NIO使用Native函数库在堆外内存上直接分配内存，但直接内存不足时，也会导致OOM。</p>\n<p><strong>第四，方法区。</strong>随着Metaspace元数据区的引入，方法区的OOM错误信息也变成了“java.lang.OutOfMemoryError:Metaspace”。对于旧版本的Oracle JDK，由于永久代的大小有限，而JVM对永久代的垃圾回收并不积极，如果往永久代不断写入数据，例如String.Intern()的调用，在永久代占用太多空间导致内存不足，也会出现OOM的问题，对应的错误信为“java.lang.OutOfMemoryError:PermGen space”</p>"},{"title":"tomcat 出现的PermGen Space问题","date":"2019-03-05T14:05:24.000Z","declare":true,"_content":"> 记录一下以前遇到的问题\n\n问题： \ntomcat服务器运行一段时间，总是会自动报异常：java.lang.OutOfmemoryError: PermGen Space 的错误，导致项目无法正常运行。\n介绍： \nPermGen Space：指的是内存的永久保存区，该块内存主要是被JVM用来存放 class 和 mete 信息的，当 class 被加载 loader 的时候就会被存储到该内存区中，与存放类的实例的heap区不同，java中的 垃圾回收器GC 不会在主程序运行期对 PermGen space 进行清理。\n原因：\n  1. 当我们的应用中有很多的class时，很可能就会出现PermGen space的错误。\n  2. 我们的 tomcat 在重启的时候，不是使用的 ./bin/shutdown.sh 而是使用 kill -9 xxx 直接杀掉，这样的话，存在 PermGen space 里面的内存不会被释放的，这样多长进行 kill 之后，就会导致系统的内存被渐渐吃完了，直到最后 tomcat 报错。\n\n <!--more-->\n解决方法：\n## Windows下 ##\n手动设置MaxPermSize的大小\n修改 TOMCAT_HOME/bin/catalina.bat文件\n在echo \"using CATALINA_BASE：$CATALINA_BASE\"上面加入这一行内容：\n\n``set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128m -XX:MaxPermSize=512m``\n\n如果是服务模式启动的，在tomcat7w的Java栏里填入：\n``-XX:MaxPermSize=512m``\n\n## Linux下 ##\n如果是 linux 环境，则修改 TOMCAT_HOME/bin/catalina.sh：\n\n``JAVA_OPTS=\"$JAVA_OPTS\" -server -XX:PermSize=128m -XX:MaxSize=512m``\n\n\n  1. 在关闭重启 tomcat 的过程中使用 shutdown.sh 而不是 使用 kill -9\n  2. 如果使用 shutdown.sh 不能将 tomcat 关掉的话，就必须要使用 kill -9 来关闭了，这个时候只有手动的来回收垃圾了： 在 linux 命令下执行如下的命令，把 缓存给丢弃掉。\necho 3 > /proc/sys/vm/drop_caches ","source":"_posts/tomcat 出现的PermGen Space问题.md","raw":"---\ntitle: tomcat 出现的PermGen Space问题\ndate: 2019-03-05 22:05:24\ntags: Tomcat\ndeclare: true\n---\n> 记录一下以前遇到的问题\n\n问题： \ntomcat服务器运行一段时间，总是会自动报异常：java.lang.OutOfmemoryError: PermGen Space 的错误，导致项目无法正常运行。\n介绍： \nPermGen Space：指的是内存的永久保存区，该块内存主要是被JVM用来存放 class 和 mete 信息的，当 class 被加载 loader 的时候就会被存储到该内存区中，与存放类的实例的heap区不同，java中的 垃圾回收器GC 不会在主程序运行期对 PermGen space 进行清理。\n原因：\n  1. 当我们的应用中有很多的class时，很可能就会出现PermGen space的错误。\n  2. 我们的 tomcat 在重启的时候，不是使用的 ./bin/shutdown.sh 而是使用 kill -9 xxx 直接杀掉，这样的话，存在 PermGen space 里面的内存不会被释放的，这样多长进行 kill 之后，就会导致系统的内存被渐渐吃完了，直到最后 tomcat 报错。\n\n <!--more-->\n解决方法：\n## Windows下 ##\n手动设置MaxPermSize的大小\n修改 TOMCAT_HOME/bin/catalina.bat文件\n在echo \"using CATALINA_BASE：$CATALINA_BASE\"上面加入这一行内容：\n\n``set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128m -XX:MaxPermSize=512m``\n\n如果是服务模式启动的，在tomcat7w的Java栏里填入：\n``-XX:MaxPermSize=512m``\n\n## Linux下 ##\n如果是 linux 环境，则修改 TOMCAT_HOME/bin/catalina.sh：\n\n``JAVA_OPTS=\"$JAVA_OPTS\" -server -XX:PermSize=128m -XX:MaxSize=512m``\n\n\n  1. 在关闭重启 tomcat 的过程中使用 shutdown.sh 而不是 使用 kill -9\n  2. 如果使用 shutdown.sh 不能将 tomcat 关掉的话，就必须要使用 kill -9 来关闭了，这个时候只有手动的来回收垃圾了： 在 linux 命令下执行如下的命令，把 缓存给丢弃掉。\necho 3 > /proc/sys/vm/drop_caches ","slug":"tomcat 出现的PermGen Space问题","published":1,"updated":"2019-04-22T07:20:49.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuuqqv65000fucxv1ni0lmo7","content":"<blockquote>\n<p>记录一下以前遇到的问题</p>\n</blockquote>\n<p>问题：<br>tomcat服务器运行一段时间，总是会自动报异常：java.lang.OutOfmemoryError: PermGen Space 的错误，导致项目无法正常运行。<br>介绍：<br>PermGen Space：指的是内存的永久保存区，该块内存主要是被JVM用来存放 class 和 mete 信息的，当 class 被加载 loader 的时候就会被存储到该内存区中，与存放类的实例的heap区不同，java中的 垃圾回收器GC 不会在主程序运行期对 PermGen space 进行清理。<br>原因：</p>\n<ol>\n<li>当我们的应用中有很多的class时，很可能就会出现PermGen space的错误。</li>\n<li><p>我们的 tomcat 在重启的时候，不是使用的 ./bin/shutdown.sh 而是使用 kill -9 xxx 直接杀掉，这样的话，存在 PermGen space 里面的内存不会被释放的，这样多长进行 kill 之后，就会导致系统的内存被渐渐吃完了，直到最后 tomcat 报错。</p>\n<a id=\"more\"></a>\n<p>解决方法：</p>\n<h2 id=\"Windows下\"><a href=\"#Windows下\" class=\"headerlink\" title=\"Windows下\"></a>Windows下</h2><p>手动设置MaxPermSize的大小<br>修改 TOMCAT_HOME/bin/catalina.bat文件<br>在echo “using CATALINA_BASE：$CATALINA_BASE”上面加入这一行内容：</p>\n</li>\n</ol>\n<p><code>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128m -XX:MaxPermSize=512m</code></p>\n<p>如果是服务模式启动的，在tomcat7w的Java栏里填入：<br><code>-XX:MaxPermSize=512m</code></p>\n<h2 id=\"Linux下\"><a href=\"#Linux下\" class=\"headerlink\" title=\"Linux下\"></a>Linux下</h2><p>如果是 linux 环境，则修改 TOMCAT_HOME/bin/catalina.sh：</p>\n<p><code>JAVA_OPTS=&quot;$JAVA_OPTS&quot; -server -XX:PermSize=128m -XX:MaxSize=512m</code></p>\n<ol>\n<li>在关闭重启 tomcat 的过程中使用 shutdown.sh 而不是 使用 kill -9</li>\n<li>如果使用 shutdown.sh 不能将 tomcat 关掉的话，就必须要使用 kill -9 来关闭了，这个时候只有手动的来回收垃圾了： 在 linux 命令下执行如下的命令，把 缓存给丢弃掉。<br>echo 3 &gt; /proc/sys/vm/drop_caches </li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>记录一下以前遇到的问题</p>\n</blockquote>\n<p>问题：<br>tomcat服务器运行一段时间，总是会自动报异常：java.lang.OutOfmemoryError: PermGen Space 的错误，导致项目无法正常运行。<br>介绍：<br>PermGen Space：指的是内存的永久保存区，该块内存主要是被JVM用来存放 class 和 mete 信息的，当 class 被加载 loader 的时候就会被存储到该内存区中，与存放类的实例的heap区不同，java中的 垃圾回收器GC 不会在主程序运行期对 PermGen space 进行清理。<br>原因：</p>\n<ol>\n<li>当我们的应用中有很多的class时，很可能就会出现PermGen space的错误。</li>\n<li><p>我们的 tomcat 在重启的时候，不是使用的 ./bin/shutdown.sh 而是使用 kill -9 xxx 直接杀掉，这样的话，存在 PermGen space 里面的内存不会被释放的，这样多长进行 kill 之后，就会导致系统的内存被渐渐吃完了，直到最后 tomcat 报错。</p></li></ol>","more":"<p>解决方法：</p>\n<h2 id=\"Windows下\"><a href=\"#Windows下\" class=\"headerlink\" title=\"Windows下\"></a>Windows下</h2><p>手动设置MaxPermSize的大小<br>修改 TOMCAT_HOME/bin/catalina.bat文件<br>在echo “using CATALINA_BASE：$CATALINA_BASE”上面加入这一行内容：</p>\n\n\n<p><code>set JAVA_OPTS=%JAVA_OPTS% -server -XX:PermSize=128m -XX:MaxPermSize=512m</code></p>\n<p>如果是服务模式启动的，在tomcat7w的Java栏里填入：<br><code>-XX:MaxPermSize=512m</code></p>\n<h2 id=\"Linux下\"><a href=\"#Linux下\" class=\"headerlink\" title=\"Linux下\"></a>Linux下</h2><p>如果是 linux 环境，则修改 TOMCAT_HOME/bin/catalina.sh：</p>\n<p><code>JAVA_OPTS=&quot;$JAVA_OPTS&quot; -server -XX:PermSize=128m -XX:MaxSize=512m</code></p>\n<ol>\n<li>在关闭重启 tomcat 的过程中使用 shutdown.sh 而不是 使用 kill -9</li>\n<li>如果使用 shutdown.sh 不能将 tomcat 关掉的话，就必须要使用 kill -9 来关闭了，这个时候只有手动的来回收垃圾了： 在 linux 命令下执行如下的命令，把 缓存给丢弃掉。<br>echo 3 &gt; /proc/sys/vm/drop_caches </li>\n</ol>"},{"title":"what-happen-when","date":"2019-03-18T12:18:13.000Z","top":null,"_content":"> 从输入 URL 到页面加载完成的过程中都发生了什么事情？\n> 参考了https://github.com/skyline75489/what-happens-when-zh_CN 和 http://fex.baidu.com/blog/2014/05/what-happen/\n\n# 按下\"g\"键 #\n接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。\n当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。\n你打算输入 \"google.com\"，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 \"google.com\" 建议给你。\n\n## 回车键按下 ##\n为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。\n\n <!--more-->\n## USB键盘： ##\n\n键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压\n键码值存储在键盘内部电路一个叫做\"endpoint\"的寄存器内\nUSB控制器大概每隔10ms便查询一次\"endpoint\"以得到存储的键码值数据，这个最短时间间隔由键盘提供\n键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包\n这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成\"低速设备\"（USB 2.0 compliance）\n这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层\n## 虚拟键盘（触屏设备）： ##\n\n在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标\n然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮\n虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息\n这个消息又返回来向当前活跃的应用通知一个“按键按下”事件\n## 产生中断[非USB键盘] ##\n键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。\n\n(Windows)一个 WM_KEYDOWN 消息被发往应用程序\nHID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。\n\nWin32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的\"message pump\"机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。\n\nWindows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。\n\n当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。\n\n(Mac OS X)一个 KeyDown NSEvent被发往应用程序\n中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。\n\n(GNU/Linux)Xorg 服务器监听键码值\n当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。\n\n# 解析URL #\n浏览器通过 URL 能够知道下面的信息：\n\nProtocol \"http\"\n使用HTTP协议\nResource \"/\"\n请求的资源是主页(index)\n输入的是 URL 还是搜索的关键字？\n当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。\n\n## 转换非 ASCII 的 Unicode 字符 ##\n浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符\n这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码\n检查 HSTS 列表\n浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站\n如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送\n注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。\n## DNS 查询 ##\n浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。\n如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。\ngethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同\n如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。\n查询本地 DNS 服务器\n如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询\n如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询\nARP 过程\n要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。\n\n首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC\n如果缓存没有命中：\n\n查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。\n查询选择的网络接口的 MAC 地址\n我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：\nARP Request:\n\nSender MAC: interface:mac:address:here\nSender IP: interface.ip.goes.here\nTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)\nTarget IP: target.ip.goes.here\n根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：\n\n直连：\n\n如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。\n集线器：\n\n如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。\n交换机：\n\n如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。\n如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 \n# ARP 请求 #\n如果路由器也“连接”在其中，它会返回一个 ARP Reply\nARP Reply:\n\nSender MAC: target:mac:address:here\nSender IP: target.ip.goes.here\nTarget MAC: interface:mac:address:here\nTarget IP: interface.ip.goes.here\n现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：\n\n使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议\n如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回\n# 使用套接字 #\n当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。\n\n这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)\nTCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。\n这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。\n到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：\n\n以太网\nWiFi\n蜂窝数据网络\n对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。\n\n大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。\n\n最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。\n\n上面的发送和接受过程在 TCP 连接期间会发生很多次：\n\n客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号\n服务器端接收到 SYN 包，如果它可以建立连接：\n服务器端选择它自己的初始序列号\n服务器端设置 SYN 位，表明自己选择了一个初始序列号\n服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个\n## 封包 ##\n客户端通过发送下面一个封包来确认这次连接：\n自己的序列号+1\n接收端 ACK+1\n设置 ACK 位\n数据通过下面的方式传输：\n当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N\n另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号\n关闭连接时：\n要关闭连接的一方发送一个 FIN 包\n另一方确认这个 FIN 包，并且发送自己的 FIN 包\n要关闭的一方使用 ACK 包来确认接收到了 FIN\n# TLS 握手 #\n客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。\n服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥\n客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥\n服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥\n客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值\n服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密\n从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容\n# HTTP 协议 #\n如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。\n\n如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:\n\nGET / HTTP/1.1\nHost: google.com\nConnection: close\n[其他头部]\n“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。）\n\nHTTP/1.1 定义了“关闭连接”的选项 \"close\"，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：\n\nConnection:close\n不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 \"close\" 选项。\n\n在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。\n\n服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:\n\n200 OK\n[响应头部]\n然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。\n\n如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:\n\n304 Not Modified\n[响应头部]\n这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。\n\n在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对www.google.com的URL) HTTP/1.1 。\n\n如果HTML引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。\n\n# HTTP 服务器请求处理 #\nHTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。\n\nHTTPD 接收请求\n服务器把请求拆分为以下几个参数：\nHTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法\n域名：google.com\n请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)\n服务器验证其上已经配置了 google.com 的虚拟主机\n服务器验证 google.com 接受 GET 方法\n服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)\n如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求\n服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 \"/\" ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。\n服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者\n浏览器背后的故事\n当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：\n\n解析 —— HTML，CSS，JS\n渲染 —— 构建 DOM 树 -> 渲染 -> 布局 -> 绘制\n# 浏览器 #\n浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。\n\n浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。\n\n不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：\n\n一个地址栏\n后退和前进按钮\n书签选项\n刷新和停止按钮\n主页按钮\n浏览器高层架构\n\n组成浏览器的组件有：\n\n用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分\n浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作\n渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上\n网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现\nUI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现\nJavascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码\n数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制\n# HTML 解析 #\n浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。\n\nHTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。\n\n解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是\"Document\"对象。整个 DOM 和 HTML 文档几乎是一对一的关系。\n\n解析算法\n\nHTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:\n\n语言本身的“宽容”特性\nHTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们\n解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容\n由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。\n\n解析结束之后\n\n浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。\n\n此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。\n\n注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。\n\n# CSS 解析 #\n根据 CSS词法和句法 分析CSS文件和style标签包含的内容以及 style 属性的值\n每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象\nCSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器\n\n# 页面渲染 #\n通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值\n通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算\"Frame 树\"中每个节点的首选(preferred)宽度\n通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度\n通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度\n使用上面的计算结果构建每个节点的坐标\n当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work\n创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层\n页面上的每个层都被分配了纹理(?)\n每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制\n上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量\n计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。\n# GPU 渲染 #\n在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU\n当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。\nWindow Server\n后期渲染与用户引发的处理\n渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制","source":"_posts/what-happen-when.md","raw":"---\ntitle: what-happen-when\ndate: 2019-03-18 20:18:13\ntags: 其他\ntop: \n---\n> 从输入 URL 到页面加载完成的过程中都发生了什么事情？\n> 参考了https://github.com/skyline75489/what-happens-when-zh_CN 和 http://fex.baidu.com/blog/2014/05/what-happen/\n\n# 按下\"g\"键 #\n接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。\n当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。\n你打算输入 \"google.com\"，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 \"google.com\" 建议给你。\n\n## 回车键按下 ##\n为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。\n\n <!--more-->\n## USB键盘： ##\n\n键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压\n键码值存储在键盘内部电路一个叫做\"endpoint\"的寄存器内\nUSB控制器大概每隔10ms便查询一次\"endpoint\"以得到存储的键码值数据，这个最短时间间隔由键盘提供\n键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包\n这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成\"低速设备\"（USB 2.0 compliance）\n这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层\n## 虚拟键盘（触屏设备）： ##\n\n在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标\n然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮\n虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息\n这个消息又返回来向当前活跃的应用通知一个“按键按下”事件\n## 产生中断[非USB键盘] ##\n键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。\n\n(Windows)一个 WM_KEYDOWN 消息被发往应用程序\nHID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。\n\nWin32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的\"message pump\"机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。\n\nWindows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。\n\n当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。\n\n(Mac OS X)一个 KeyDown NSEvent被发往应用程序\n中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。\n\n(GNU/Linux)Xorg 服务器监听键码值\n当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。\n\n# 解析URL #\n浏览器通过 URL 能够知道下面的信息：\n\nProtocol \"http\"\n使用HTTP协议\nResource \"/\"\n请求的资源是主页(index)\n输入的是 URL 还是搜索的关键字？\n当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。\n\n## 转换非 ASCII 的 Unicode 字符 ##\n浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符\n这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码\n检查 HSTS 列表\n浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站\n如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送\n注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。\n## DNS 查询 ##\n浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。\n如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。\ngethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同\n如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。\n查询本地 DNS 服务器\n如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询\n如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询\nARP 过程\n要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。\n\n首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC\n如果缓存没有命中：\n\n查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。\n查询选择的网络接口的 MAC 地址\n我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：\nARP Request:\n\nSender MAC: interface:mac:address:here\nSender IP: interface.ip.goes.here\nTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)\nTarget IP: target.ip.goes.here\n根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：\n\n直连：\n\n如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。\n集线器：\n\n如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。\n交换机：\n\n如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。\n如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 \n# ARP 请求 #\n如果路由器也“连接”在其中，它会返回一个 ARP Reply\nARP Reply:\n\nSender MAC: target:mac:address:here\nSender IP: target.ip.goes.here\nTarget MAC: interface:mac:address:here\nTarget IP: interface.ip.goes.here\n现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：\n\n使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议\n如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回\n# 使用套接字 #\n当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。\n\n这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)\nTCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。\n这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。\n到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：\n\n以太网\nWiFi\n蜂窝数据网络\n对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。\n\n大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。\n\n最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。\n\n上面的发送和接受过程在 TCP 连接期间会发生很多次：\n\n客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号\n服务器端接收到 SYN 包，如果它可以建立连接：\n服务器端选择它自己的初始序列号\n服务器端设置 SYN 位，表明自己选择了一个初始序列号\n服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个\n## 封包 ##\n客户端通过发送下面一个封包来确认这次连接：\n自己的序列号+1\n接收端 ACK+1\n设置 ACK 位\n数据通过下面的方式传输：\n当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N\n另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号\n关闭连接时：\n要关闭连接的一方发送一个 FIN 包\n另一方确认这个 FIN 包，并且发送自己的 FIN 包\n要关闭的一方使用 ACK 包来确认接收到了 FIN\n# TLS 握手 #\n客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。\n服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥\n客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥\n服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥\n客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值\n服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密\n从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容\n# HTTP 协议 #\n如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。\n\n如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:\n\nGET / HTTP/1.1\nHost: google.com\nConnection: close\n[其他头部]\n“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。）\n\nHTTP/1.1 定义了“关闭连接”的选项 \"close\"，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：\n\nConnection:close\n不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 \"close\" 选项。\n\n在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。\n\n服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:\n\n200 OK\n[响应头部]\n然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。\n\n如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:\n\n304 Not Modified\n[响应头部]\n这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。\n\n在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对www.google.com的URL) HTTP/1.1 。\n\n如果HTML引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。\n\n# HTTP 服务器请求处理 #\nHTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。\n\nHTTPD 接收请求\n服务器把请求拆分为以下几个参数：\nHTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法\n域名：google.com\n请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)\n服务器验证其上已经配置了 google.com 的虚拟主机\n服务器验证 google.com 接受 GET 方法\n服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)\n如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求\n服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 \"/\" ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。\n服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者\n浏览器背后的故事\n当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：\n\n解析 —— HTML，CSS，JS\n渲染 —— 构建 DOM 树 -> 渲染 -> 布局 -> 绘制\n# 浏览器 #\n浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。\n\n浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。\n\n不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：\n\n一个地址栏\n后退和前进按钮\n书签选项\n刷新和停止按钮\n主页按钮\n浏览器高层架构\n\n组成浏览器的组件有：\n\n用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分\n浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作\n渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上\n网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现\nUI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现\nJavascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码\n数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制\n# HTML 解析 #\n浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。\n\nHTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。\n\n解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是\"Document\"对象。整个 DOM 和 HTML 文档几乎是一对一的关系。\n\n解析算法\n\nHTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:\n\n语言本身的“宽容”特性\nHTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们\n解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容\n由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。\n\n解析结束之后\n\n浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。\n\n此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。\n\n注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。\n\n# CSS 解析 #\n根据 CSS词法和句法 分析CSS文件和style标签包含的内容以及 style 属性的值\n每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象\nCSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器\n\n# 页面渲染 #\n通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值\n通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算\"Frame 树\"中每个节点的首选(preferred)宽度\n通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度\n通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度\n使用上面的计算结果构建每个节点的坐标\n当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work\n创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层\n页面上的每个层都被分配了纹理(?)\n每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制\n上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量\n计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。\n# GPU 渲染 #\n在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU\n当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。\nWindow Server\n后期渲染与用户引发的处理\n渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制","slug":"what-happen-when","published":1,"updated":"2019-04-24T06:59:04.065Z","_id":"cjuuqqv7u000zucxveeah1xlz","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>从输入 URL 到页面加载完成的过程中都发生了什么事情？<br>参考了<a href=\"https://github.com/skyline75489/what-happens-when-zh_CN\" target=\"_blank\" rel=\"noopener\">https://github.com/skyline75489/what-happens-when-zh_CN</a> 和 <a href=\"http://fex.baidu.com/blog/2014/05/what-happen/\" target=\"_blank\" rel=\"noopener\">http://fex.baidu.com/blog/2014/05/what-happen/</a></p>\n</blockquote>\n<h1 id=\"按下”g”键\"><a href=\"#按下”g”键\" class=\"headerlink\" title=\"按下”g”键\"></a>按下”g”键</h1><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。<br>当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。<br>你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。</p>\n<h2 id=\"回车键按下\"><a href=\"#回车键按下\" class=\"headerlink\" title=\"回车键按下\"></a>回车键按下</h2><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。</p>\n <a id=\"more\"></a>\n<h2 id=\"USB键盘：\"><a href=\"#USB键盘：\" class=\"headerlink\" title=\"USB键盘：\"></a>USB键盘：</h2><p>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压<br>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内<br>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供<br>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包<br>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）<br>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</p>\n<h2 id=\"虚拟键盘（触屏设备）：\"><a href=\"#虚拟键盘（触屏设备）：\" class=\"headerlink\" title=\"虚拟键盘（触屏设备）：\"></a>虚拟键盘（触屏设备）：</h2><p>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标<br>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮<br>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息<br>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</p>\n<h2 id=\"产生中断-非USB键盘\"><a href=\"#产生中断-非USB键盘\" class=\"headerlink\" title=\"产生中断[非USB键盘]\"></a>产生中断[非USB键盘]</h2><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p>\n<p>(Windows)一个 WM_KEYDOWN 消息被发往应用程序<br>HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p>\n<p>Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>\n<p>Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。</p>\n<p>当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。</p>\n<p>(Mac OS X)一个 KeyDown NSEvent被发往应用程序<br>中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。</p>\n<p>(GNU/Linux)Xorg 服务器监听键码值<br>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p>\n<h1 id=\"解析URL\"><a href=\"#解析URL\" class=\"headerlink\" title=\"解析URL\"></a>解析URL</h1><p>浏览器通过 URL 能够知道下面的信息：</p>\n<p>Protocol “http”<br>使用HTTP协议<br>Resource “/“<br>请求的资源是主页(index)<br>输入的是 URL 还是搜索的关键字？<br>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>\n<h2 id=\"转换非-ASCII-的-Unicode-字符\"><a href=\"#转换非-ASCII-的-Unicode-字符\" class=\"headerlink\" title=\"转换非 ASCII 的 Unicode 字符\"></a>转换非 ASCII 的 Unicode 字符</h2><p>浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符<br>这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码<br>检查 HSTS 列表<br>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站<br>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送<br>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</p>\n<h2 id=\"DNS-查询\"><a href=\"#DNS-查询\" class=\"headerlink\" title=\"DNS 查询\"></a>DNS 查询</h2><p>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。<br>如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。<br>gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同<br>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。<br>查询本地 DNS 服务器<br>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询<br>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询<br>ARP 过程<br>要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p>\n<p>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC<br>如果缓存没有命中：</p>\n<p>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。<br>查询选择的网络接口的 MAC 地址<br>我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：<br>ARP Request:</p>\n<p>Sender MAC: interface:mac:address:here<br>Sender IP: interface.ip.goes.here<br>Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)<br>Target IP: target.ip.goes.here<br>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>\n<p>直连：</p>\n<p>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。<br>集线器：</p>\n<p>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。<br>交换机：</p>\n<p>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。<br>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 </p>\n<h1 id=\"ARP-请求\"><a href=\"#ARP-请求\" class=\"headerlink\" title=\"ARP 请求\"></a>ARP 请求</h1><p>如果路由器也“连接”在其中，它会返回一个 ARP Reply<br>ARP Reply:</p>\n<p>Sender MAC: target:mac:address:here<br>Sender IP: target.ip.goes.here<br>Target MAC: interface:mac:address:here<br>Target IP: interface.ip.goes.here<br>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>\n<p>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议<br>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</p>\n<h1 id=\"使用套接字\"><a href=\"#使用套接字\" class=\"headerlink\" title=\"使用套接字\"></a>使用套接字</h1><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。</p>\n<p>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)<br>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。<br>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。<br>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>\n<p>以太网<br>WiFi<br>蜂窝数据网络<br>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。</p>\n<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。</p>\n<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>\n<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>\n<p>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号<br>服务器端接收到 SYN 包，如果它可以建立连接：<br>服务器端选择它自己的初始序列号<br>服务器端设置 SYN 位，表明自己选择了一个初始序列号<br>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个</p>\n<h2 id=\"封包\"><a href=\"#封包\" class=\"headerlink\" title=\"封包\"></a>封包</h2><p>客户端通过发送下面一个封包来确认这次连接：<br>自己的序列号+1<br>接收端 ACK+1<br>设置 ACK 位<br>数据通过下面的方式传输：<br>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N<br>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号<br>关闭连接时：<br>要关闭连接的一方发送一个 FIN 包<br>另一方确认这个 FIN 包，并且发送自己的 FIN 包<br>要关闭的一方使用 ACK 包来确认接收到了 FIN</p>\n<h1 id=\"TLS-握手\"><a href=\"#TLS-握手\" class=\"headerlink\" title=\"TLS 握手\"></a>TLS 握手</h1><p>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。<br>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥<br>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥<br>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥<br>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值<br>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密<br>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</p>\n<h1 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h1><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p>\n<p>如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:</p>\n<p>GET / HTTP/1.1<br>Host: google.com<br>Connection: close<br>[其他头部]<br>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。）</p>\n<p>HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：</p>\n<p>Connection:close<br>不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 “close” 选项。</p>\n<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>\n<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p>\n<p>200 OK<br>[响应头部]<br>然后是一个换行，接下来有效载荷(payload)，也就是 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a> 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。</p>\n<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p>\n<p>304 Not Modified<br>[响应头部]<br>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>\n<p>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对<a href=\"http://www.google.com的URL\" target=\"_blank\" rel=\"noopener\">www.google.com的URL</a>) HTTP/1.1 。</p>\n<p>如果HTML引入了 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。</p>\n<h1 id=\"HTTP-服务器请求处理\"><a href=\"#HTTP-服务器请求处理\" class=\"headerlink\" title=\"HTTP 服务器请求处理\"></a>HTTP 服务器请求处理</h1><p>HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>\n<p>HTTPD 接收请求<br>服务器把请求拆分为以下几个参数：<br>HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法<br>域名：google.com<br>请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)<br>服务器验证其上已经配置了 google.com 的虚拟主机<br>服务器验证 google.com 接受 GET 方法<br>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)<br>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求<br>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。<br>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者<br>浏览器背后的故事<br>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>\n<p>解析 —— HTML，CSS，JS<br>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</p>\n<h1 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h1><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>\n<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>\n<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>\n<p>一个地址栏<br>后退和前进按钮<br>书签选项<br>刷新和停止按钮<br>主页按钮<br>浏览器高层架构</p>\n<p>组成浏览器的组件有：</p>\n<p>用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分<br>浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作<br>渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上<br>网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现<br>UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现<br>Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码<br>数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</p>\n<h1 id=\"HTML-解析\"><a href=\"#HTML-解析\" class=\"headerlink\" title=\"HTML 解析\"></a>HTML 解析</h1><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>\n<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>\n<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>\n<p>解析算法</p>\n<p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>\n<p>语言本身的“宽容”特性<br>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们<br>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容<br>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>\n<p>解析结束之后</p>\n<p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>\n<p>此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。</p>\n<p>注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。</p>\n<h1 id=\"CSS-解析\"><a href=\"#CSS-解析\" class=\"headerlink\" title=\"CSS 解析\"></a>CSS 解析</h1><p>根据 CSS词法和句法 分析CSS文件和style标签包含的内容以及 style 属性的值<br>每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象<br>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</p>\n<h1 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h1><p>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值<br>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度<br>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度<br>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度<br>使用上面的计算结果构建每个节点的坐标<br>当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见<a href=\"http://dev.w3.org/csswg/css2/\" target=\"_blank\" rel=\"noopener\">http://dev.w3.org/csswg/css2/</a> 和 <a href=\"http://www.w3.org/Style/CSS/current-work\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/Style/CSS/current-work</a><br>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层<br>页面上的每个层都被分配了纹理(?)<br>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制<br>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量<br>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</p>\n<h1 id=\"GPU-渲染\"><a href=\"#GPU-渲染\" class=\"headerlink\" title=\"GPU 渲染\"></a>GPU 渲染</h1><p>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU<br>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。<br>Window Server<br>后期渲染与用户引发的处理<br>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>从输入 URL 到页面加载完成的过程中都发生了什么事情？<br>参考了<a href=\"https://github.com/skyline75489/what-happens-when-zh_CN\" target=\"_blank\" rel=\"noopener\">https://github.com/skyline75489/what-happens-when-zh_CN</a> 和 <a href=\"http://fex.baidu.com/blog/2014/05/what-happen/\" target=\"_blank\" rel=\"noopener\">http://fex.baidu.com/blog/2014/05/what-happen/</a></p>\n</blockquote>\n<h1 id=\"按下”g”键\"><a href=\"#按下”g”键\" class=\"headerlink\" title=\"按下”g”键\"></a>按下”g”键</h1><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。<br>当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。<br>你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。</p>\n<h2 id=\"回车键按下\"><a href=\"#回车键按下\" class=\"headerlink\" title=\"回车键按下\"></a>回车键按下</h2><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。</p>","more":"<h2 id=\"USB键盘：\"><a href=\"#USB键盘：\" class=\"headerlink\" title=\"USB键盘：\"></a>USB键盘：</h2><p>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压<br>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内<br>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供<br>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包<br>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）<br>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</p>\n<h2 id=\"虚拟键盘（触屏设备）：\"><a href=\"#虚拟键盘（触屏设备）：\" class=\"headerlink\" title=\"虚拟键盘（触屏设备）：\"></a>虚拟键盘（触屏设备）：</h2><p>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标<br>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮<br>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息<br>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</p>\n<h2 id=\"产生中断-非USB键盘\"><a href=\"#产生中断-非USB键盘\" class=\"headerlink\" title=\"产生中断[非USB键盘]\"></a>产生中断[非USB键盘]</h2><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p>\n<p>(Windows)一个 WM_KEYDOWN 消息被发往应用程序<br>HID把键盘按下的事件传送给 KBDHID.sys 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p>\n<p>Win32K.sys 通过 GetForegroundWindow() API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>\n<p>Windows的 SendMessage API直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。</p>\n<p>当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。</p>\n<p>(Mac OS X)一个 KeyDown NSEvent被发往应用程序<br>中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 WindowServer 进程。然后， WindowServer 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。</p>\n<p>(GNU/Linux)Xorg 服务器监听键码值<br>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p>\n<h1 id=\"解析URL\"><a href=\"#解析URL\" class=\"headerlink\" title=\"解析URL\"></a>解析URL</h1><p>浏览器通过 URL 能够知道下面的信息：</p>\n<p>Protocol “http”<br>使用HTTP协议<br>Resource “/“<br>请求的资源是主页(index)<br>输入的是 URL 还是搜索的关键字？<br>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>\n<h2 id=\"转换非-ASCII-的-Unicode-字符\"><a href=\"#转换非-ASCII-的-Unicode-字符\" class=\"headerlink\" title=\"转换非 ASCII 的 Unicode 字符\"></a>转换非 ASCII 的 Unicode 字符</h2><p>浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符<br>这里主机名是 google.com ，所以没有非ASCII的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码<br>检查 HSTS 列表<br>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站<br>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送<br>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</p>\n<h2 id=\"DNS-查询\"><a href=\"#DNS-查询\" class=\"headerlink\" title=\"DNS 查询\"></a>DNS 查询</h2><p>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。<br>如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。<br>gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同<br>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。<br>查询本地 DNS 服务器<br>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询<br>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询<br>ARP 过程<br>要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p>\n<p>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC<br>如果缓存没有命中：</p>\n<p>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。<br>查询选择的网络接口的 MAC 地址<br>我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：<br>ARP Request:</p>\n<p>Sender MAC: interface:mac:address:here<br>Sender IP: interface.ip.goes.here<br>Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)<br>Target IP: target.ip.goes.here<br>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>\n<p>直连：</p>\n<p>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。<br>集线器：</p>\n<p>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。<br>交换机：</p>\n<p>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。<br>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 </p>\n<h1 id=\"ARP-请求\"><a href=\"#ARP-请求\" class=\"headerlink\" title=\"ARP 请求\"></a>ARP 请求</h1><p>如果路由器也“连接”在其中，它会返回一个 ARP Reply<br>ARP Reply:</p>\n<p>Sender MAC: target:mac:address:here<br>Sender IP: target.ip.goes.here<br>Target MAC: interface:mac:address:here<br>Target IP: interface.ip.goes.here<br>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>\n<p>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议<br>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</p>\n<h1 id=\"使用套接字\"><a href=\"#使用套接字\" class=\"headerlink\" title=\"使用套接字\"></a>使用套接字</h1><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。</p>\n<p>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)<br>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个IP packet。<br>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。<br>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>\n<p>以太网<br>WiFi<br>蜂窝数据网络<br>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。</p>\n<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。</p>\n<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部 time to live (TTL) 域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>\n<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>\n<p>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号<br>服务器端接收到 SYN 包，如果它可以建立连接：<br>服务器端选择它自己的初始序列号<br>服务器端设置 SYN 位，表明自己选择了一个初始序列号<br>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个</p>\n<h2 id=\"封包\"><a href=\"#封包\" class=\"headerlink\" title=\"封包\"></a>封包</h2><p>客户端通过发送下面一个封包来确认这次连接：<br>自己的序列号+1<br>接收端 ACK+1<br>设置 ACK 位<br>数据通过下面的方式传输：<br>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N<br>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号<br>关闭连接时：<br>要关闭连接的一方发送一个 FIN 包<br>另一方确认这个 FIN 包，并且发送自己的 FIN 包<br>要关闭的一方使用 ACK 包来确认接收到了 FIN</p>\n<h1 id=\"TLS-握手\"><a href=\"#TLS-握手\" class=\"headerlink\" title=\"TLS 握手\"></a>TLS 握手</h1><p>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。<br>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的TLS版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥<br>客户端根据自己的信任CA列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥<br>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥<br>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值<br>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密<br>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</p>\n<h1 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h1><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p>\n<p>如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:</p>\n<p>GET / HTTP/1.1<br>Host: google.com<br>Connection: close<br>[其他头部]<br>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反HTTP协议标准的bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。）</p>\n<p>HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：</p>\n<p>Connection:close<br>不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 “close” 选项。</p>\n<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>\n<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p>\n<p>200 OK<br>[响应头部]<br>然后是一个换行，接下来有效载荷(payload)，也就是 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a> 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。</p>\n<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p>\n<p>304 Not Modified<br>[响应头部]<br>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>\n<p>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对<a href=\"http://www.google.com的URL\" target=\"_blank\" rel=\"noopener\">www.google.com的URL</a>) HTTP/1.1 。</p>\n<p>如果HTML引入了 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">www.google.com</a> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。</p>\n<h1 id=\"HTTP-服务器请求处理\"><a href=\"#HTTP-服务器请求处理\" class=\"headerlink\" title=\"HTTP 服务器请求处理\"></a>HTTP 服务器请求处理</h1><p>HTTPD(HTTP Daemon)在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>\n<p>HTTPD 接收请求<br>服务器把请求拆分为以下几个参数：<br>HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法<br>域名：google.com<br>请求路径/页面：/ (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)<br>服务器验证其上已经配置了 google.com 的虚拟主机<br>服务器验证 google.com 接受 GET 方法<br>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)<br>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求<br>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。<br>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者<br>浏览器背后的故事<br>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>\n<p>解析 —— HTML，CSS，JS<br>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</p>\n<h1 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h1><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>\n<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>\n<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>\n<p>一个地址栏<br>后退和前进按钮<br>书签选项<br>刷新和停止按钮<br>主页按钮<br>浏览器高层架构</p>\n<p>组成浏览器的组件有：</p>\n<p>用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分<br>浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作<br>渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上<br>网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现<br>UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现<br>Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码<br>数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</p>\n<h1 id=\"HTML-解析\"><a href=\"#HTML-解析\" class=\"headerlink\" title=\"HTML 解析\"></a>HTML 解析</h1><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>\n<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>\n<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>\n<p>解析算法</p>\n<p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>\n<p>语言本身的“宽容”特性<br>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们<br>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容<br>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>\n<p>解析结束之后</p>\n<p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>\n<p>此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于“推迟（deferred）”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成（complete）”，浏览器会触发“加载（load）”事件。</p>\n<p>注意解析 HTML 网页时永远不会出现“无效语法（Invalid Syntax）”错误，浏览器会修复所有错误内容，然后继续解析。</p>\n<h1 id=\"CSS-解析\"><a href=\"#CSS-解析\" class=\"headerlink\" title=\"CSS 解析\"></a>CSS 解析</h1><p>根据 CSS词法和句法 分析CSS文件和style标签包含的内容以及 style 属性的值<br>每个CSS文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象<br>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</p>\n<h1 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h1><p>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值<br>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点的首选(preferred)宽度<br>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度<br>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度<br>使用上面的计算结果构建每个节点的坐标<br>当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见<a href=\"http://dev.w3.org/csswg/css2/\" target=\"_blank\" rel=\"noopener\">http://dev.w3.org/csswg/css2/</a> 和 <a href=\"http://www.w3.org/Style/CSS/current-work\" target=\"_blank\" rel=\"noopener\">http://www.w3.org/Style/CSS/current-work</a><br>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层<br>页面上的每个层都被分配了纹理(?)<br>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制<br>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量<br>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</p>\n<h1 id=\"GPU-渲染\"><a href=\"#GPU-渲染\" class=\"headerlink\" title=\"GPU 渲染\"></a>GPU 渲染</h1><p>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU<br>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。<br>Window Server<br>后期渲染与用户引发的处理<br>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制</p>"}],"PostAsset":[{"_id":"source/_posts/jvm内存组成/memory-area1.png","slug":"memory-area1.png","post":"cjuuqqv61000ducxv2ygci3fb","modified":0,"renderable":0},{"_id":"source/_posts/HashMap常见问答/14101204468.jpeg","slug":"14101204468.jpeg","post":"cjuuqqv4y0000ucxv3wuvf121","modified":0,"renderable":0},{"_id":"source/_posts/Java代码的执行顺序/1.png","slug":"1.png","post":"cjuuqqv580001ucxv0pj12h4r","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjuuqqv5g0003ucxvv6drruyh","category_id":"cjuuqqv5n0005ucxvpnajuyix","_id":"cjuuqqv6d000gucxv2v28rze3"},{"post_id":"cjuuqqv5s0009ucxviius6qsu","category_id":"cjuuqqv5z000cucxvyjwv40o4","_id":"cjuuqqv6k000lucxvcjim9cdt"},{"post_id":"cjuuqqv5v000aucxvlm7q7286","category_id":"cjuuqqv6g000iucxvs0tddzbz","_id":"cjuuqqv6x000pucxv1xec11g7"},{"post_id":"cjuuqqv61000ducxv2ygci3fb","category_id":"cjuuqqv6g000iucxvs0tddzbz","_id":"cjuuqqv6z000rucxvgqttkgy7"}],"PostTag":[{"post_id":"cjuuqqv4y0000ucxv3wuvf121","tag_id":"cjuuqqv5d0002ucxvic7gp229","_id":"cjuuqqv5s0008ucxvigaja2p7"},{"post_id":"cjuuqqv580001ucxv0pj12h4r","tag_id":"cjuuqqv5r0007ucxvjr0duf5t","_id":"cjuuqqv63000eucxvnch11vw7"},{"post_id":"cjuuqqv5g0003ucxvv6drruyh","tag_id":"cjuuqqv5y000bucxvcl35nseu","_id":"cjuuqqv6h000jucxvsmqsqh8q"},{"post_id":"cjuuqqv5j0004ucxvhim817gq","tag_id":"cjuuqqv6e000hucxvzpk78pc8","_id":"cjuuqqv6u000nucxvuplk0fr5"},{"post_id":"cjuuqqv5p0006ucxvvzpxv11u","tag_id":"cjuuqqv6j000kucxvvcsvhir1","_id":"cjuuqqv6y000qucxv945o92n9"},{"post_id":"cjuuqqv5s0009ucxviius6qsu","tag_id":"cjuuqqv6w000oucxvvgjym8e7","_id":"cjuuqqv71000tucxvakjydmzk"},{"post_id":"cjuuqqv5v000aucxvlm7q7286","tag_id":"cjuuqqv70000sucxvgchkn00h","_id":"cjuuqqv73000vucxvhc1p960g"},{"post_id":"cjuuqqv61000ducxv2ygci3fb","tag_id":"cjuuqqv70000sucxvgchkn00h","_id":"cjuuqqv74000xucxvr98avh7q"},{"post_id":"cjuuqqv65000fucxv1ni0lmo7","tag_id":"cjuuqqv73000wucxvqh7oe4c7","_id":"cjuuqqv75000yucxv91ufyci2"},{"post_id":"cjuuqqv7u000zucxveeah1xlz","tag_id":"cjuuqqv7y0010ucxvsq5xk2kc","_id":"cjuuqqv7y0011ucxvpu0zaymy"}],"Tag":[{"name":"HashMap","_id":"cjuuqqv5d0002ucxvic7gp229"},{"name":"Java","_id":"cjuuqqv5r0007ucxvjr0duf5t"},{"name":"Java 多线程","_id":"cjuuqqv5y000bucxvcl35nseu"},{"name":"Shadowsocks","_id":"cjuuqqv6e000hucxvzpk78pc8"},{"name":"sql","_id":"cjuuqqv6j000kucxvvcsvhir1"},{"name":"test","_id":"cjuuqqv6w000oucxvvgjym8e7"},{"name":"jvm内存","_id":"cjuuqqv70000sucxvgchkn00h"},{"name":"Tomcat","_id":"cjuuqqv73000wucxvqh7oe4c7"},{"name":"其他","_id":"cjuuqqv7y0010ucxvsq5xk2kc"}]}}